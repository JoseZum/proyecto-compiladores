package ParserLexer;

import java_cup.runtime.*;

/* Conectar CUP con lexer JFlex */
scan with {: return ((Lexer)scanner).next_token(); :};

parser code {:
    public void syntax_error(Symbol s) {
        System.err.println("Error de sintaxis en línea " + s.left);
    }
:}

parser code {:

    /* ---- AST root para que el main pueda leerlo si quiere ---- */
    public Nodo raizAST = null;

    /* ===================== TABLA DE SIMBOLOS ===================== */
    static class SymInfo {
        String kind;      // VAR, ARR, PARAM, FUNC, MAIN
        String type;      // int/float/boolean/char/string/coal
        Integer dim1;     // para arreglos
        Integer dim2;     // para arreglos
        int line, col;

        SymInfo(String kind, String type, int line, int col) {
            this.kind = kind;
            this.type = type;
            this.line = line;
            this.col = col;
        }

        SymInfo(String kind, String type, int dim1, int dim2, int line, int col) {
            this.kind = kind;
            this.type = type;
            this.dim1 = dim1;
            this.dim2 = dim2;
            this.line = line;
            this.col = col;
        }

        @Override
        public String toString() {
            if (dim1 != null && dim2 != null) {
                return kind + " : " + type + "[" + dim1 + "][" + dim2 + "]" + " (" + line + "," + col + ")";
            }
            return kind + " : " + type + " (" + line + "," + col + ")";
        }
    }

    // scopeName -> (id -> SymInfo)
    HashMap<String, HashMap<String, SymInfo>> tablas = new HashMap<>();
    String currentScope = "world";   // world, navidad, nombreFuncion

    ArrayList<String> errores = new ArrayList<>();

    void initTablas() {
        if (!tablas.containsKey("world")) tablas.put("world", new HashMap<>());
        currentScope = "world";
    }

    void pushScope(String scope) {
        if (!tablas.containsKey(scope)) tablas.put(scope, new HashMap<>());
        currentScope = scope;
    }

    void popToWorld() {
        currentScope = "world";
    }

    boolean existeEnScope(String scope, String id) {
        return tablas.containsKey(scope) && tablas.get(scope).containsKey(id);
    }

    boolean existeEnAlguno(String id) {
        // primero currentScope, luego world
        if (existeEnScope(currentScope, id)) return true;
        return existeEnScope("world", id);
    }

    SymInfo getSimbolo(String id) {
        if (existeEnScope(currentScope, id)) return tablas.get(currentScope).get(id);
        if (existeEnScope("world", id)) return tablas.get("world").get(id);
        return null;
    }

    void addError(String msg) {
        errores.add(msg);
        System.err.println(msg);
    }

    void declararVar(String scope, String id, String tipo, int line, int col, boolean esParametro) {
        if (!tablas.containsKey(scope)) tablas.put(scope, new HashMap<>());

        HashMap<String, SymInfo> t = tablas.get(scope);
        if (t.containsKey(id)) {
            addError("[SEM] Duplicado en scope '" + scope + "': " + id + " (" + line + "," + col + ")");
            return;
        }
        t.put(id, new SymInfo(esParametro ? "PARAM" : "VAR", tipo, line, col));
    }

    void declararArr(String scope, String id, String tipo, int d1, int d2, int line, int col) {
        if (!tablas.containsKey(scope)) tablas.put(scope, new HashMap<>());

        HashMap<String, SymInfo> t = tablas.get(scope);
        if (t.containsKey(id)) {
            addError("[SEM] Duplicado en scope '" + scope + "': " + id + " (" + line + "," + col + ")");
            return;
        }
        t.put(id, new SymInfo("ARR", tipo, d1, d2, line, col));
    }

    void declararFuncion(String id, String tipoRet, int line, int col) {
        HashMap<String, SymInfo> world = tablas.get("world");
        if (world.containsKey(id)) {
            addError("[SEM] Duplicado global (func/var) en world: " + id + " (" + line + "," + col + ")");
            return;
        }
        world.put(id, new SymInfo("FUNC", tipoRet, line, col));
    }

    void declararMain(int line, int col) {
        HashMap<String, SymInfo> world = tablas.get("world");
        if (world.containsKey("navidad")) {
            addError("[SEM] Duplicado main navidad (" + line + "," + col + ")");
            return;
        }
        world.put("navidad", new SymInfo("MAIN", "coal", line, col));
    }

    void checkIDUsado(String id, int line, int col) {
        if (!existeEnAlguno(id)) {
            addError("[SEM] Uso de ID no declarado: " + id + " (" + line + "," + col + ")");
        }
    }

    void checkFuncionLlamada(String id, int line, int col) {
        if (!existeEnScope("world", id)) {
            addError("[SEM] Llamada a función inexistente: " + id + " (" + line + "," + col + ")");
            return;
        }
        SymInfo si = tablas.get("world").get(id);
        if (!"FUNC".equals(si.kind) && !"MAIN".equals(si.kind)) {
            addError("[SEM] Llamada a no-función: " + id + " (" + line + "," + col + ")");
        }
    }

    void checkArrayAcceso(String id, int line, int col) {
        SymInfo si = getSimbolo(id);
        if (si == null) {
            addError("[SEM] Acceso a arreglo no declarado: " + id + " (" + line + "," + col + ")");
            return;
        }
        if (!"ARR".equals(si.kind)) {
            addError("[SEM] Acceso tipo arreglo sobre símbolo no-arreglo: " + id + " (" + line + "," + col + ")");
        }
    }

    void printTablas() {
        System.out.println("\n================ TABLAS DE SIMBOLOS ================");
        for (String scope : tablas.keySet()) {
            System.out.println("Scope: " + scope);
            HashMap<String, SymInfo> t = tablas.get(scope);
            for (String id : t.keySet()) {
                System.out.println("  " + id + " -> " + t.get(id));
            }
            System.out.println();
        }
        if (!errores.isEmpty()) {
            System.out.println("================ ERRORES/AVISOS ================");
            for (String e : errores) System.out.println(e);
        }
        System.out.println("====================================================\n");
    }

    /* ===================== ERRORES SINTACTICOS ===================== */
    public void syntax_error(Symbol s) {
        addError("[SINT] Error de sintaxis en línea " + s.left + ", cerca de token: " + terminalToString(s));
    }

    public void report_error(String message, Object info) {
        addError("[SINT] " + message);
    }

    private String terminalToString(Symbol s) {
        try {
            return sym.terminalNames[s.sym] + (s.value != null ? ("('" + s.value + "')") : "");
        } catch(Exception e) {
            return "<?>"; 
        }
    }

:}

/* init */
init with {: initTablas(); :};

precedence left OR;
precedence left AND;
precedence right NOT;

precedence left PLUS, MINUS;
precedence left TIMES, DIV, DIV_INT, MODULE;
precedence right POWER;

precedence right UMINUS;

precedence right INCREMENT, DECREMENT;


/* ------------TERMINALES------------ */

terminal BLOCK_OPEN, BLOCK_CLOSE, NAVIDAD, GIFT, WORLD, INT, FLOAT, BOOLEAN, CHAR, STRING, LOCAL, COAL_TYPE;
terminal DECIDE, OF, END, ELSE, LOOP, EXIT, WHEN, FOR, BREAK, RETURN;
terminal ARROW, ENDL, ASSIGN, PARENTHESIS_OPEN, PARENTHESIS_CLOSE, ARRAY_OPEN, ARRAY_CLOSE, COMMA;
terminal PLUS, MINUS, TIMES, DIV_INT, DIV, MODULE, POWER;
terminal LESS_OR_EQ_THAN, LESS_THAN, MORE_OR_EQ_THAN, MORE_THAN, EQUALS, DIFFERENT;
terminal AND, OR, NOT;
terminal DECREMENT, INCREMENT;
terminal SHOW, GET;
terminal INT_LIT, FLOAT_LIT, BOOLEAN_LIT, CHAR_LIT, STRING_LIT;
terminal ID;

/* ------------NO TERMINALES------------ */

non terminal programa, funciones, funcion, main;
non terminal tipo, literal, alcance;
non terminal params, param;
non terminal creacion, creacion_sentencia, asignacion, asignacion_sentencia;
non terminal unario;
non terminal sentencias, sentencia, bloque;
non terminal estructura, for_init, for, loop, decide_of;
non terminal casos, caso;
non terminal arreglo, dim, decl_arreglo, creacion_arreglo;
non terminal asignacion_elemento, acceso_arreglo;
non terminal elementos, fila, filas, arreglo_init;
non terminal tipo_arreglo, lit_array;
non terminal llamada, args;
non terminal expresion;
non terminal expr_aritm, term, power, factor;
non terminal expr_relacional, expresion_rel, operador_rel;
non terminal expr_logica, expr_and, expr_not, expr_bool;
non terminal io, show, show_arg, get, get_target;

/* ------------INICIO------------ */

start with programa;

/* ------------PRODUCCIONES------------ */

programa ::= funciones main
           | main
           ;

funciones ::= funciones funcion
            | funcion
            ;

/* -----Datos----- */

tipo ::=
      INT     {: Nodo n=new Nodo("int");     n.setTipo("int");     RESULT=n; :}
    | FLOAT   {: Nodo n=new Nodo("float");   n.setTipo("float");   RESULT=n; :}
    | BOOLEAN {: Nodo n=new Nodo("boolean"); n.setTipo("boolean"); RESULT=n; :}
    | CHAR    {: Nodo n=new Nodo("char");    n.setTipo("char");    RESULT=n; :}
    | STRING  {: Nodo n=new Nodo("string");  n.setTipo("string");  RESULT=n; :}
    ;

literal ::=
      INT_LIT:i      {: Nodo n=new Nodo(i); n.setTipo("int");     RESULT=n; :}
    | FLOAT_LIT:f    {: Nodo n=new Nodo(f); n.setTipo("float");   RESULT=n; :}
    | BOOLEAN_LIT:b  {: Nodo n=new Nodo(b); n.setTipo("boolean"); RESULT=n; :}
    | CHAR_LIT:c     {: Nodo n=new Nodo(c); n.setTipo("char");    RESULT=n; :}
    | STRING_LIT:s   {: Nodo n=new Nodo(s); n.setTipo("string");  RESULT=n; :}
    ;

alcance ::= WORLD | LOCAL ;

/* -----funciones----- */

params ::= params COMMA param
         | param
         ;

param ::= tipo ID ;

main ::= COAL_TYPE NAVIDAD PARENTHESIS_OPEN PARENTHESIS_CLOSE bloque ;

funcion ::= GIFT tipo ID PARENTHESIS_OPEN params PARENTHESIS_CLOSE bloque |
            GIFT tipo ID PARENTHESIS_OPEN PARENTHESIS_CLOSE bloque;

/* -----Declaraciones----- */

creacion ::= alcance tipo ID
           | asignacion
           ;

creacion_sentencia ::= creacion ENDL ;

asignacion ::= alcance tipo ID ASSIGN expresion ;

asignacion_sentencia ::= asignacion ENDL ;

unario ::= INCREMENT ID
         | DECREMENT ID
         | INCREMENT acceso_arreglo
         | DECREMENT acceso_arreglo
         ;

/* -----sentencias----- */

sentencias ::= sentencias sentencia
             | sentencia
             ;

sentencia ::= asignacion_sentencia
            | creacion_sentencia
            | estructura
            | expresion ENDL
            | asignacion_elemento
            | io
            | BREAK ENDL
            | RETURN expresion ENDL
            ;

bloque ::= BLOCK_OPEN sentencias BLOCK_CLOSE
         | BLOCK_OPEN BLOCK_CLOSE
         ;

/* -----control----- */

estructura ::= for
             | loop
             | decide_of
             | arreglo
             ;

for_init ::= asignacion
           | creacion
           ;

for ::= FOR PARENTHESIS_OPEN for_init ENDL expr_logica ENDL unario PARENTHESIS_CLOSE bloque ;

loop ::= LOOP bloque EXIT WHEN expr_logica ENDL END LOOP ENDL ;

casos ::= casos caso
        | caso
        ;

caso ::= expr_logica ARROW bloque ;

decide_of ::= DECIDE OF casos END DECIDE ENDL
            | DECIDE OF casos ELSE bloque END DECIDE ENDL
            ;

/* -----arreglos----- */

arreglo ::= creacion_arreglo ;

dim ::= ARRAY_OPEN INT_LIT ARRAY_CLOSE ARRAY_OPEN INT_LIT ARRAY_CLOSE ;

decl_arreglo ::= tipo ID dim ;

creacion_arreglo ::= alcance decl_arreglo ENDL
                   | alcance decl_arreglo ASSIGN arreglo_init ENDL
                   ;

asignacion_elemento ::= acceso_arreglo ASSIGN lit_array ENDL ;

acceso_arreglo ::= ID ARRAY_OPEN expresion ARRAY_CLOSE ARRAY_OPEN expresion ARRAY_CLOSE ;

elementos ::= lit_array
            | elementos COMMA lit_array
            ;

fila ::= BLOCK_OPEN elementos BLOCK_CLOSE ;

filas ::= fila
        | filas COMMA fila
        ;

arreglo_init ::= BLOCK_OPEN filas BLOCK_CLOSE ;


lit_array ::= INT_LIT | CHAR_LIT ;

/* -----llamadas----- */

llamada ::= ID PARENTHESIS_OPEN args PARENTHESIS_CLOSE
          | ID PARENTHESIS_OPEN PARENTHESIS_CLOSE
          ;

args ::= args COMMA expresion
       | expresion
       ;

/* -----Expresiones----- */

expresion ::= literal
            | ID
            | expr_aritm
            | expr_relacional
            | expr_logica
            | acceso_arreglo
            | llamada
            ;

/* -----aritmeicas----- */

expr_aritm ::= expr_aritm PLUS term
             | expr_aritm MINUS term
             | term
             ;

term ::= term TIMES power
       | term DIV power
       | term DIV_INT power
       | term MODULE power
       | power
       ;

power ::= factor POWER power
        | factor
        ;

factor ::= literal
         | ID
         | acceso_arreglo
         | llamada
         | MINUS factor
         | unario
         | PARENTHESIS_OPEN expresion PARENTHESIS_CLOSE
         ;

/* -----relacionales----- */

expr_relacional ::= expresion_rel operador_rel expresion_rel ;

expresion_rel ::= expr_aritm
                | BOOLEAN_LIT
                | ID
                ;

operador_rel ::= LESS_THAN
               | LESS_OR_EQ_THAN
               | MORE_THAN
               | MORE_OR_EQ_THAN
               | EQUALS
               | DIFFERENT
               ;

/* -----logicas----- */

expr_logica ::= expr_logica OR expr_and
              | expr_and
              ;

expr_and ::= expr_and AND expr_not
           | expr_not
           ;

expr_not ::= NOT expr_not
           | expr_bool
           ;

expr_bool ::= BOOLEAN_LIT
            | ID
            | expr_relacional
            | PARENTHESIS_OPEN expr_logica PARENTHESIS_CLOSE
            ;

/* -----I/O----- */

io ::= show
     | get
     ;

show ::= SHOW PARENTHESIS_OPEN show_arg PARENTHESIS_CLOSE ENDL ;

show_arg ::= literal
           | ID
           | acceso_arreglo
           ;

get ::= GET PARENTHESIS_OPEN get_target PARENTHESIS_CLOSE ENDL ;

get_target ::= ID
             | acceso_arreglo
             ;

