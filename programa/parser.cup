package ParserLexer;

import java_cup.runtime.*;

/* Conectar CUP con lexer JFlex */
scan with {: return ((Lexer)scanner).next_token(); :};

parser code {:
    public void syntax_error(Symbol s) {
        System.err.println("Error de sintaxis en línea " + s.left);
    }
:}

/* ========================= TABLA DE SIMBOLOS =============================== */

parser code {:

    // Apunta a la raiz del AST 
    public Nodo raizAST = null;

    //SYMINFO: Qué guarda cada símbolo en la tabla de simbolos

    static class SymInfo {
        String kind;      // VAR, ARR, PARAM, FUNC, MAIN
        String type;      // int/float/boolean/char/string/coal
        Integer dim1;     // para arreglos
        Integer dim2;     // para arreglos
        int line, col;

        SymInfo(String kind, String type, int line, int col) {
            this.kind = kind;
            this.type = type;
            this.line = line;
            this.col = col;
        }

        SymInfo(String kind, String type, int dim1, int dim2, int line, int col) {
            this.kind = kind;
            this.type = type;
            this.dim1 = dim1;
            this.dim2 = dim2;
            this.line = line;
            this.col = col;
        }

        @Override
        public String toString() {
            if (dim1 != null && dim2 != null) {
                return kind + " : " + type + "[" + dim1 + "][" + dim2 + "]" + " (" + line + "," + col + ")";
            }
            return kind + " : " + type + " (" + line + "," + col + ")";
        }
    }

    // Tablas por scope específico | scopeName -> (id -> SymInfo) 
    HashMap<String, HashMap<String, SymInfo>> tablas = new HashMap<>();

    // Jerarquía de Scopes | scopeName -> parentScopeName  (jerarquía)
    HashMap<String, String> parentScope = new HashMap<>();

    // Contador de nombres únicos para los scopes
    HashMap<String, Integer> counters = new HashMap<>();
    
    // Pila real de scopes
    Deque<String> scopeStack = new ArrayDeque<>();

    ArrayList<String> errores = new ArrayList<>();

    // Tabla Global: Inicializa y pone el scope en world
    void initTablas() {
        tablas.put("world", new HashMap<>());
        parentScope.put("world", null);
        scopeStack.clear();
        scopeStack.push("world");
    }

    String currentScope() {
        return scopeStack.peek();
    }

    // Genera máscara única basada en el scope actual + kind
    String genScopeName(String kind) {
        String parent = currentScope();
        String key = parent + "#" + kind;
        int n = counters.getOrDefault(key, 0) + 1;
        counters.put(key, n);
        return parent + "_" + kind + n;   // ej: navidad_bloque1, NombreFunc_for2, NombreFunc_for2_bloque1...
    }
    
    /* Hace 3 cosas:
    1. Si no existe una tabla para un scope especifico, la crea
    2. Si no tiene papá registrado, pone de padre al scope actual
    3. Mete el scope a la pila y lo vuelve el current
     */
    void pushNamedScope(String name) {
        if (!tablas.containsKey(name)) tablas.put(name, new HashMap<>());
        if (!parentScope.containsKey(name)) parentScope.put(name, currentScope());
        scopeStack.push(name);
    }

    // Entra a un scope nuevo (lo mete a la pila) y le genera una máscara
    void pushAutoScope(String kind) {
        pushNamedScope(genScopeName(kind));
    }

    // Sale del scope actual
    void popScope() {
        if (scopeStack.size() > 1) scopeStack.pop(); // nunca sacar world
    }
    
    void addError(String msg) {
        errores.add(msg);
        System.err.println(msg);
    }

    /* Visibilidad hacia arriba:
    Busca una variable/func/arreglo siguiendo la jerarquía de scopes
    Si el símbolo no está en el current, sube al papá, y así hasta encontrarlo o llegar a world y poner null
    
     */
    SymInfo lookup(String id) {
        String s = currentScope();
        while (s != null) {
            HashMap<String, SymInfo> t = tablas.get(s);
            if (t != null && t.containsKey(id)) return t.get(id);
            s = parentScope.get(s); // Sube al tata
        }
        return null;
    }
    // Revisa si el ID ya existe en el scope actual para detectar duplicados
    boolean existsInCurrent(String id) {
        return tablas.get(currentScope()).containsKey(id);
    }

    // Verifica que un identificador exista 
    void checkID(String id, int line, int col) {
        if (lookup(id) == null) {
            addError("[SEM] Uso de ID no declarado: " + id + " (" + line + "," + col + ")");
        }
    }

    // Declara un símbolo en un scope específico
    void declareInScope(String scope, String id, SymInfo info) {
        HashMap<String, SymInfo> t = tablas.get(scope);
        if (t.containsKey(id)) {
            addError("[SEM] Duplicado en scope '" + scope + "': " + id + " (" + info.line + "," + info.col + ")");
            return;
        }
        t.put(id, info);
    }

    // Declara variables o parámetros y los mete a la tabla que corresponda (local o world)
    void declareVar(String alcance, String tipo, String id, int line, int col, boolean isParam) {
        if ("world".equals(alcance)) {
            declareInScope("world", id, new SymInfo(isParam ? "PARAM" : "VAR", tipo, line, col));
            return;
        }
        // local
        if ("world".equals(currentScope())) {
            addError("[SEM] 'local' fuera de función/navidad/bloque: " + id + " (" + line + "," + col + ")");
            return;
        }
        declareInScope(currentScope(), id, new SymInfo(isParam ? "PARAM" : "VAR", tipo, line, col));
    }

    // Igual que declareVar pero para arrays
    void declareArr(String alcance, String tipo, String id, int d1, int d2, int line, int col) {
        if ("world".equals(alcance)) {
            declareInScope("world", id, new SymInfo("ARR", tipo, d1, d2, line, col));
            return;
        }
        if ("world".equals(currentScope())) {
            addError("[SEM] 'local' fuera de función/navidad/bloque (arreglo): " + id + " (" + line + "," + col + ")");
            return;
        }
        declareInScope(currentScope(), id, new SymInfo("ARR", tipo, d1, d2, line, col));
    }

|   // Declara una función en world
    void declareFunc(String id, String tipoRet, int line, int col) {
        HashMap<String, SymInfo> w = tablas.get("world");
        if (w.containsKey(id)) {
            addError("[SEM] Duplicado global en world: " + id + " (" + line + "," + col + ")");
            return;
        }
        w.put(id, new SymInfo("FUNC", tipoRet, line, col));
    }

    // Declara el main navidad en world
    void declareMain(int line, int col) {
        HashMap<String, SymInfo> w = tablas.get("world");
        if (w.containsKey("navidad")) {
            addError("[SEM] Duplicado main navidad (" + line + "," + col + ")");
            return;
        }
        w.put("navidad", new SymInfo("MAIN", "coal", line, col));
    }

    // Verifica llamadas, que ID exista en world y sea FUNC o MAIN
    void checkCall(String id, int line, int col) {
        HashMap<String, SymInfo> w = tablas.get("world");
        if (!w.containsKey(id)) {
            addError("[SEM] Llamada a función inexistente: " + id + " (" + line + "," + col + ")");
            return;
        }
        String k = w.get(id).kind;
        if (!"FUNC".equals(k) && !"MAIN".equals(k)) {
            addError("[SEM] Llamada a no-función: " + id + " (" + line + "," + col + ")");
        }
    }

    // Verifica que el id exista y que sea ARR
    void checkArray(String id, int line, int col) {
        SymInfo si = lookup(id);
        if (si == null) {
            addError("[SEM] Acceso a arreglo no declarado: " + id + " (" + line + "," + col + ")");
            return;
        }
        if (!"ARR".equals(si.kind)) {
            addError("[SEM] Acceso arreglo sobre símbolo no-arreglo: " + id + " (" + line + "," + col + ")");
        }
    }

    void printTablas() {
        System.out.println("\n================ TABLAS DE SIMBOLOS (JERARQUIA) ==============");
        // Imprimir en orden jerárquico: world y luego lo otro
        System.out.println("Scope: world");
        for (Map.Entry<String, SymInfo> e : tablas.get("world").entrySet()) {
            System.out.println("  " + e.getKey() + " -> " + e.getValue());
        }
        System.out.println();

        for (String scope : tablas.keySet()) {
            if ("world".equals(scope)) continue;
            System.out.println("Scope: " + scope + " (parent=" + parentScope.get(scope) + ")");
            for (Map.Entry<String, SymInfo> e : tablas.get(scope).entrySet()) {
                System.out.println("  " + e.getKey() + " -> " + e.getValue());
            }
            System.out.println();
        }

        if (!errores.isEmpty()) {
            System.out.println("================ ERRORES/AVISOS ================");
            for (String e : errores) System.out.println(e);
        }
        System.out.println("=================================================\n");
    }

    /*======== ERRORES SINTACTICOS =========*/
    public void syntax_error(Symbol s) {
        addError("[SINT] Error de sintaxis en línea " + s.left + " cerca de: " + terminalToString(s));
    }

    public void report_error(String message, Object info) {
        addError("[SINT] " + message);
    }

    private String terminalToString(Symbol s) {
        try {
            return sym.terminalNames[s.sym] + (s.value != null ? ("('" + s.value + "')") : "");
        } catch(Exception e) {
            return "<?>"; 
        }
    }

:}

init with {: initTablas(); :};

precedence left OR;
precedence left AND;
precedence right NOT;

precedence left PLUS, MINUS;
precedence left TIMES, DIV, DIV_INT, MODULE;
precedence right POWER;

precedence right UMINUS;

precedence right INCREMENT, DECREMENT;


/* ------------TERMINALES------------ */

terminal BLOCK_OPEN, BLOCK_CLOSE, NAVIDAD, GIFT, WORLD, INT, FLOAT, BOOLEAN, CHAR, STRING, LOCAL, COAL_TYPE;
terminal DECIDE, OF, END, ELSE, LOOP, EXIT, WHEN, FOR, BREAK, RETURN;
terminal ARROW, ENDL, ASSIGN, PARENTHESIS_OPEN, PARENTHESIS_CLOSE, ARRAY_OPEN, ARRAY_CLOSE, COMMA;
terminal PLUS, MINUS, TIMES, DIV_INT, DIV, MODULE, POWER;
terminal LESS_OR_EQ_THAN, LESS_THAN, MORE_OR_EQ_THAN, MORE_THAN, EQUALS, DIFFERENT;
terminal AND, OR, NOT;
terminal DECREMENT, INCREMENT;
terminal SHOW, GET;
terminal INT_LIT, FLOAT_LIT, BOOLEAN_LIT, CHAR_LIT, STRING_LIT;
terminal ID;

/* ------------NO TERMINALES------------ */

non terminal programa, funciones, funcion, main;
non terminal tipo, literal, alcance;
non terminal params, param;
non terminal creacion, creacion_sentencia, asignacion, asignacion_sentencia;
non terminal unario;
non terminal sentencias, sentencia, bloque;
non terminal estructura, for_init, for, loop, decide_of;
non terminal casos, caso;
non terminal arreglo, dim, decl_arreglo, creacion_arreglo;
non terminal asignacion_elemento, acceso_arreglo;
non terminal elementos, fila, filas, arreglo_init;
non terminal tipo_arreglo, lit_array;
non terminal llamada, args;
non terminal expresion;
non terminal expr_aritm, term, power, factor;
non terminal expr_relacional, expresion_rel, operador_rel;
non terminal expr_logica, expr_and, expr_not, expr_bool;
non terminal io, show, show_arg, get, get_target;

/* ------------INICIO------------ */

start with programa;

/* ------------PRODUCCIONES------------ */

programa ::=
      funciones:f main:m
      {:
          Nodo n = new Nodo("programa");
          n.addHijo((Nodo)f); // Hijo 1: Lista de funciones
          n.addHijo((Nodo)m); // Hijo 2: Main (Navidad)
          raizAST = n;

          System.out.println("Programa reconocido.");
          raizAST.arbol();
          printTablas();

          RESULT = n;
      :}
    | main:m
      {:
          Nodo n = new Nodo("programa");
          n.addHijo((Nodo)m);
          raizAST = n;

          System.out.println("Programa reconocido.");
          raizAST.arbol();
          printTablas();

          RESULT = n;
      :}
    ;

funciones ::=
      funciones:fs funcion:fn
      {:
          Nodo n = (Nodo)fs;
          n.addHijo((Nodo)fn);
          RESULT = n;
      :}
    | funcion:fn
      {:
          Nodo n = new Nodo("funciones");
          n.addHijo((Nodo)fn);
          RESULT = n;
      :}
    ;

/* -----Datos----- */

tipo ::=
      INT {:Nodo n=new Nodo("int");     n.setTipo("int");     RESULT=n; :}
    | FLOAT {:Nodo n=new Nodo("float");   n.setTipo("float");   RESULT=n; :}
    | BOOLEAN {:Nodo n=new Nodo("boolean"); n.setTipo("boolean"); RESULT=n; :}
    | CHAR {:Nodo n=new Nodo("char");    n.setTipo("char");    RESULT=n; :}
    | STRING {:Nodo n=new Nodo("string");  n.setTipo("string");  RESULT=n; :}
    ;

literal ::=
      INT_LIT:i {: Nodo n=new Nodo(i); n.setTipo("int"); RESULT=n; :}
    | FLOAT_LIT:f {: Nodo n=new Nodo(f); n.setTipo("float"); RESULT=n; :}
    | BOOLEAN_LIT:b {: Nodo n=new Nodo(b); n.setTipo("boolean"); RESULT=n; :}
    | CHAR_LIT:c {: Nodo n=new Nodo(c); n.setTipo("char"); RESULT=n; :}
    | STRING_LIT:s {: Nodo n=new Nodo(s); n.setTipo("string"); RESULT=n; :}
    ;

alcance ::= WORLD | LOCAL ;

/* -----funciones----- */

params_opt ::=
      params:p {: RESULT=(Nodo)p; :}
    | /* empty */ {: RESULT=new Nodo("params_vacios"); :}
    ;

params ::=
      params:ps COMMA param:p
      {:
          Nodo n=(Nodo)ps;
          n.addHijo(new Nodo(","));
          n.addHijo((Nodo)p);
          RESULT=n;
      :}
    | param:p
      {:
          Nodo n=new Nodo("params");
          n.addHijo((Nodo)p);
          RESULT=n;
      :}
    ;

param ::=
      tipo:t ID:id
      {:
          // parámetros: se declaran en el scope de la función (no en el bloque)
          declareVar("local", ((Nodo)t).getTipo(), id, idleft, idright, true);

          Nodo n=new Nodo("param");
          n.addHijo((Nodo)t);
          Nodo nid=new Nodo(id); nid.setTipo(((Nodo)t).getTipo());
          n.addHijo(nid);
          RESULT=n;
      :}
    ;

/* ----- main ----- */
main ::=
      COAL_TYPE NAVIDAD
      {:
          declareMain(NAVIDADleft, NAVIDADright); // Registra navidad en world como MAIN
          pushNamedScope("navidad"); // Crea y entra al scope "Navidad"
      :}
      PARENTHESIS_OPEN PARENTHESIS_CLOSE bloque:b
      {:
          Nodo n=new Nodo("main");
          n.addHijo(new Nodo("coal"));
          n.addHijo(new Nodo("navidad"));
          n.addHijo((Nodo)b);

          // Salir del scope navidad (los bloques ya se hicieron pop solos)
          popScope();

          RESULT=n;
      :}
    ;

/* ----- funcion ----- */
funcion ::=
      GIFT tipo:t ID:id
      {:
          declareFunc(id, ((Nodo)t).getTipo(), idleft, idright);
          pushNamedScope(id);
      :}
      PARENTHESIS_OPEN params_opt:po PARENTHESIS_CLOSE bloque:b
      {:
          Nodo n=new Nodo("funcion");
          n.addHijo(new Nodo("gift"));
          Nodo nid=new Nodo(id); nid.setTipo(((Nodo)t).getTipo());
          n.addHijo((Nodo)t);
          n.addHijo(nid);
          n.addHijo((Nodo)po);
          n.addHijo((Nodo)b);

          // salir del scope de función
          popScope();

          RESULT=n;
      :}
    ;

/* -----Declaraciones----- */

creacion ::=
      alcance:a tipo:t ID:id
      {:
          String alc = ((Nodo)a).getTipo(); // world/local
          declareVar(alc, ((Nodo)t).getTipo(), id, idleft, idright, false);

          Nodo n=new Nodo("creacion");
          n.addHijo((Nodo)a);
          Nodo nid=new Nodo(id); nid.setTipo(((Nodo)t).getTipo());
          n.addHijo((Nodo)t);
          n.addHijo(nid);
          RESULT=n;
      :}
    ;

creacion_sentencia ::=
      creacion:c ENDL
      {:
          Nodo n=new Nodo("creacion_sent");
          n.addHijo((Nodo)c);
          RESULT=n;
      :}
    ;

asignacion ::=
      alcance:a tipo:t ID:id ASSIGN expresion:e
      {:
          String alc=((Nodo)a).getTipo();
          // en tu lenguaje esto es declaracion+asignacion
          declareVar(alc, ((Nodo)t).getTipo(), id, idleft, idright, false);

          Nodo n=new Nodo("asignacion_decl");
          n.addHijo((Nodo)a);
          Nodo nid=new Nodo(id); nid.setTipo(((Nodo)t).getTipo());
          n.addHijo((Nodo)t);
          n.addHijo(nid);
          n.addHijo(new Nodo("="));
          n.addHijo((Nodo)e);
          RESULT=n;
      :}
    ;

asignacion_sentencia ::=
      asignacion:a ENDL
      {:
          Nodo n=new Nodo("asignacion_sent");
          n.addHijo((Nodo)a);
          RESULT=n;
      :}
    ;

unario ::= INCREMENT ID
         | DECREMENT ID
         | INCREMENT acceso_arreglo
         | DECREMENT acceso_arreglo
         ;

/* -----sentencias----- */

sentencias ::=
      sentencias:ss sentencia:s
      {:
          Nodo n=(Nodo)ss;
          n.addHijo((Nodo)s);
          RESULT=n;
      :}
    | sentencia:s
      {:
          Nodo n=new Nodo("sentencias");
          n.addHijo((Nodo)s);
          RESULT=n;
      :}
    ;
    
/* Una sentencia puede ser:
     - declaración, asignación, estructura, expr endl, io, break, return
     - o error ENDL (panic mode) 
    Cada caso crea un nodo distinto
    */    

sentencia ::=
      asignacion_sentencia
    | creacion_sentencia
    | estructura
    | expresion:e ENDL
      {:
          Nodo n=new Nodo("expr_sent");
          n.addHijo((Nodo)e);
          RESULT=n;
      :}
    | asignacion_elemento
    | io
    | BREAK ENDL
      {:
          Nodo n=new Nodo("break");
          RESULT=n;
      :}
    | RETURN expresion:e ENDL
      {:
          Nodo n=new Nodo("return");
          n.addHijo((Nodo)e);
          RESULT=n;
      :}
    | error ENDL
      {:
          addError("[PANIC] Sentencia inválida, sincronizado en ENDL.");
          RESULT=new Nodo("sentencia_error");
      :}
    ;

// BLOQUE: por cada ¡ ! crea una tabla nueva (máscara) 
bloque ::=
      BLOCK_OPEN
      {:
          // Scope por bloque específico (máscara única)
          pushAutoScope("bloque");
      :}
      sentencias:s
      BLOCK_CLOSE
      {:
          Nodo n=new Nodo("bloque");
          n.addHijo(new Nodo("¡"));
          n.addHijo((Nodo)s);
          n.addHijo(new Nodo("!"));
          RESULT=n;

          popScope();
      :}
    | BLOCK_OPEN
      {:
          pushAutoScope("bloque");
      :}
      BLOCK_CLOSE
      {:
          Nodo n=new Nodo("bloque_vacio");
          n.addHijo(new Nodo("¡"));
          n.addHijo(new Nodo("!"));
          RESULT=n;
          popScope();
      :}
    | BLOCK_OPEN
      {:
          pushAutoScope("bloque");
      :}
      error
      BLOCK_CLOSE
      {:
          addError("[PANIC] Bloque inválido, sincronizado en '!'.");
          RESULT=new Nodo("bloque_error");
          popScope();
      :}
    ;

/* ----- Control ----- */
estructura ::=
      for
    | loop
    | decide_of
    | arreglo
    ;

/* for_init va DENTRO del scope del for */
for_init ::=
      asignacion
    | creacion
    ;

// FOR: abre scope propio ANTES de parsear init 
for ::=
      FOR
      {:
          pushAutoScope("for");
      :}
      PARENTHESIS_OPEN for_init:fi ENDL expr_logica:cond ENDL unario:u PARENTHESIS_CLOSE bloque:b
      {:
          Nodo n=new Nodo("for");
          n.addHijo((Nodo)fi);
          n.addHijo((Nodo)cond);
          n.addHijo((Nodo)u);
          n.addHijo((Nodo)b);
          RESULT=n;

          // cerrar scope del for (bloques internos ya se cerraron)
          popScope();
      :}
    ;

// LOOP: scope propio del loop (aunque el bloque también tenga scope) 
loop ::=
      LOOP
      {:
          pushAutoScope("loop");
      :}
      bloque:b EXIT WHEN expr_logica:cond ENDL END LOOP ENDL
      {:
          Nodo n=new Nodo("loop");
          n.addHijo((Nodo)b);
          n.addHijo((Nodo)cond);
          RESULT=n;
          popScope();
      :}
    ;

casos ::=
      casos:cs caso:c
      {:
          Nodo n=(Nodo)cs;
          n.addHijo((Nodo)c);
          RESULT=n;
      :}
    | caso:c
      {:
          Nodo n=new Nodo("casos");
          n.addHijo((Nodo)c);
          RESULT=n;
      :}
    ;

caso ::=
      expr_logica:cond ARROW bloque:b
      {:
          Nodo n=new Nodo("caso");
          n.addHijo((Nodo)cond);
          n.addHijo((Nodo)b);
          RESULT=n;
      :}
    ;

// DECIDE: scope propio del decide_of 
decide_of ::=
      DECIDE
      {:
          pushAutoScope("decide");
      :}
      OF casos:cs END DECIDE ENDL
      {:
          Nodo n=new Nodo("decide_of");
          n.addHijo((Nodo)cs);
          RESULT=n;
          popScope();
      :}
    | DECIDE
      {:
          pushAutoScope("decide");
      :}
      OF casos:cs ELSE bloque:b END DECIDE ENDL
      {:
          Nodo n=new Nodo("decide_of");
          n.addHijo((Nodo)cs);
          n.addHijo((Nodo)b);
          RESULT=n;
          popScope();
      :}
    ;

/* -----arreglos----- */

arreglo ::= creacion_arreglo ;

dim ::= ARRAY_OPEN INT_LIT ARRAY_CLOSE ARRAY_OPEN INT_LIT ARRAY_CLOSE ;

decl_arreglo ::= tipo ID dim ;

creacion_arreglo ::= alcance decl_arreglo ENDL
                   | alcance decl_arreglo ASSIGN arreglo_init ENDL
                   ;

asignacion_elemento ::= acceso_arreglo ASSIGN lit_array ENDL ;

acceso_arreglo ::= ID ARRAY_OPEN expresion ARRAY_CLOSE ARRAY_OPEN expresion ARRAY_CLOSE ;

elementos ::= lit_array
            | elementos COMMA lit_array
            ;

fila ::= BLOCK_OPEN elementos BLOCK_CLOSE ;

filas ::= fila
        | filas COMMA fila
        ;

arreglo_init ::= BLOCK_OPEN filas BLOCK_CLOSE ;


lit_array ::= INT_LIT | CHAR_LIT ;

/* -----llamadas----- */

llamada ::= ID PARENTHESIS_OPEN args PARENTHESIS_CLOSE
          | ID PARENTHESIS_OPEN PARENTHESIS_CLOSE
          ;

args ::= args COMMA expresion
       | expresion
       ;

/* -----Expresiones----- */

expresion ::= literal
            | ID
            | expr_aritm
            | expr_relacional
            | expr_logica
            | acceso_arreglo
            | llamada
            ;

/* -----aritmeicas----- */

expr_aritm ::= expr_aritm PLUS term
             | expr_aritm MINUS term
             | term
             ;

term ::= term TIMES power
       | term DIV power
       | term DIV_INT power
       | term MODULE power
       | power
       ;

power ::= factor POWER power
        | factor
        ;

factor ::= literal
         | ID
         | acceso_arreglo
         | llamada
         | MINUS factor
         | unario
         | PARENTHESIS_OPEN expresion PARENTHESIS_CLOSE
         ;

/* -----relacionales----- */

expr_relacional ::= expresion_rel operador_rel expresion_rel ;

expresion_rel ::= expr_aritm
                | BOOLEAN_LIT
                | ID
                ;

operador_rel ::= LESS_THAN
               | LESS_OR_EQ_THAN
               | MORE_THAN
               | MORE_OR_EQ_THAN
               | EQUALS
               | DIFFERENT
               ;

/* -----logicas----- */

expr_logica ::= expr_logica OR expr_and
              | expr_and
              ;

expr_and ::= expr_and AND expr_not
           | expr_not
           ;

expr_not ::= NOT expr_not
           | expr_bool
           ;

expr_bool ::= BOOLEAN_LIT
            | ID
            | expr_relacional
            | PARENTHESIS_OPEN expr_logica PARENTHESIS_CLOSE
            ;

/* -----I/O----- */

io ::= show
     | get
     ;

show ::= SHOW PARENTHESIS_OPEN show_arg PARENTHESIS_CLOSE ENDL ;

show_arg ::= literal
           | ID
           | acceso_arreglo
           ;

get ::= GET PARENTHESIS_OPEN get_target PARENTHESIS_CLOSE ENDL ;

get_target ::= ID
             | acceso_arreglo
             ;

