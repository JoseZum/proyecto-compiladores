/*
 * parser.cup contiene la gramatica, scopes, tabla de simbolos analizador lexico y sintáctico para el lenguaje 
 */

import java_cup.runtime.*;
import java.util.*;

// Conectar CUP con el lexer generado por JFlex
scan with {: return ((Lexer)getScanner()).next_token(); :};

// Esperamos 1 conflicto shift/reduce en expresiones con paréntesis (CUP resuelve a favor de shift)

/* ---------- TABLA DE SIMBOLOS ---------- */

parser code {:
    public Nodo raizAST = null;

    
    static class SymInfo {
        // clase para almacenar info de simbolos en la tabla
        String kind;      // VAR, ARR, PARAM, FUNC, MAIN
        String type;      // int/float/boolean/char/string/coal
        Integer dim1;     // para arreglos
        Integer dim2;     // para arreglos
        int line, col;

        SymInfo(String kind, String type, int line, int col) {
            this.kind = kind;
            this.type = type;
            this.line = line;
            this.col = col;
        }

        SymInfo(String kind, String type, int dim1, int dim2, int line, int col) {
            this.kind = kind;
            this.type = type;
            this.dim1 = dim1;
            this.dim2 = dim2;
            this.line = line;
            this.col = col;
        }

        @Override
        public String toString() {
            if (dim1 != null && dim2 != null) {
                return kind + " : " + type + "[" + dim1 + "][" + dim2 + "]" + " (" + line + "," + col + ")";
            }
            return kind + " : " + type + " (" + line + "," + col + ")";
        }
    }

    // ---------- estructuras para scopes y tabla de simbolos ----------

    // Mapa: nombre de scope -> (id -> SymInfo)
    HashMap<String, HashMap<String, SymInfo>> tablas = new HashMap<>();

    // Mapa: nombre de scope -> nombre del scope padre
    HashMap<String, String> parentScope = new HashMap<>();

    // Contador para generar nombres únicos de scopes anidados
    HashMap<String, Integer> counters = new HashMap<>();

    // Pila de scopes activos (jerarquía actual)
    Deque<String> scopeStack = new ArrayDeque<>();

    // Lista de errores semánticos y sintácticos encontrados
    ArrayList<String> errores = new ArrayList<>();

    /**
     * Inicializa la tabla de símbolos global y el scope "world".
     */
    void initTablas() {
        tablas.put("world", new HashMap<>());
        parentScope.put("world", null);
        scopeStack.clear();
        scopeStack.push("world");
    }

    /**
     * Obtiene el nombre del scope actual
     */
    String currentScope() {
        return scopeStack.peek();
    }

    /**
     * Genera un nombre único para un nuevo scope hijo, basado en el scope actual y el tipo de bloque.
     * @param kind Tipo de bloque (ej: for, bloque, etc)
     * @return Nombre único de scope
     */
    String genScopeName(String kind) {
        String parent = currentScope();
        String key = parent + "#" + kind;
        int n = counters.getOrDefault(key, 0) + 1;
        counters.put(key, n);
        return parent + "_" + kind + n; 
    }

    /**
     * Entra a un scope nombrado 
     * @param name Nombre del nuevo scope
     */
    void pushNamedScope(String name) {
        if (!tablas.containsKey(name)) tablas.put(name, new HashMap<>());
        if (!parentScope.containsKey(name)) parentScope.put(name, currentScope());
        scopeStack.push(name);
    }

    /**
     * Entra a un scope nuevo y le genera un nombre unico según el tipo
     * @param kind Tipo de bloque
     */
    void pushAutoScope(String kind) {
        pushNamedScope(genScopeName(kind));
    }

    // Sale del scope actual
    void popScope() {
        if (scopeStack.size() > 1) scopeStack.pop();
    }
    
    void addError(String msg) {
        errores.add(msg);
        System.err.println(msg);
    }

    /* Visibilidad hacia arriba:
    busca una expresion o funcion siguiendo la jerarquia de scopes
    Si el simbolo no está en el current, sube al papa, y asi hasta encontrarlo o llegar a world y poner null
    
     */
    SymInfo lookup(String id) {
        String s = currentScope();
        while (s != null) {
            HashMap<String, SymInfo> t = tablas.get(s);
            if (t != null && t.containsKey(id)) return t.get(id);
            s = parentScope.get(s); // Sube al tata
        }
        return null;
    }
    // Revisa si el ID ya existe en el scope actual para detectar duplicados
    boolean existsInCurrent(String id) {
        return tablas.get(currentScope()).containsKey(id);
    }

    // Verifica que un identificador exista 
    void checkID(String id, int line, int col) {
        if (lookup(id) == null) {
            addError("[SEM] Uso de ID no declarado: " + id + " (" + line + "," + col + ")");
        }
    }

    // Declara un símbolo en un scope específico
    void declareInScope(String scope, String id, SymInfo info) {
        HashMap<String, SymInfo> t = tablas.get(scope);
        if (t.containsKey(id)) {
            addError("[SEM] Duplicado en scope '" + scope + "': " + id + " (" + info.line + "," + info.col + ")");
            return;
        }
        t.put(id, info);
    }

    // Declara variables o parametros y los mete a la tabla que corresponda
    void declareVar(String alcance, String tipo, String id, int line, int col, boolean isParam) {
        if ("world".equals(alcance)) {
            declareInScope("world", id, new SymInfo(isParam ? "PARAM" : "VAR", tipo, line, col));
            return;
        }
        // local
        if ("world".equals(currentScope())) {
            addError("[SEM] 'local' fuera de función/navidad/bloque: " + id + " (" + line + "," + col + ")");
            return;
        }
        declareInScope(currentScope(), id, new SymInfo(isParam ? "PARAM" : "VAR", tipo, line, col));
    }

    // Igual que declareVar pero para arrays
    void declareArr(String alcance, String tipo, String id, int d1, int d2, int line, int col) {
        if ("world".equals(alcance)) {
            declareInScope("world", id, new SymInfo("ARR", tipo, d1, d2, line, col));
            return;
        }
        if ("world".equals(currentScope())) {
            addError("[SEM] 'local' fuera de función/navidad/bloque (arreglo): " + id + " (" + line + "," + col + ")");
            return;
        }
        declareInScope(currentScope(), id, new SymInfo("ARR", tipo, d1, d2, line, col));
    }

    // Declara una función en world
    void declareFunc(String id, String tipoRet, int line, int col) {
        HashMap<String, SymInfo> w = tablas.get("world");
        if (w.containsKey(id)) {
            addError("[SEM] Duplicado global en world: " + id + " (" + line + "," + col + ")");
            return;
        }
        w.put(id, new SymInfo("FUNC", tipoRet, line, col));
    }

    // Declara el main navidad en world
    void declareMain(int line, int col) {
        HashMap<String, SymInfo> w = tablas.get("world");
        if (w.containsKey("navidad")) {
            addError("[SEM] Duplicado main navidad (" + line + "," + col + ")");
            return;
        }
        w.put("navidad", new SymInfo("MAIN", "coal", line, col));
    }

    void checkCall(String id, int line, int col) {
        HashMap<String, SymInfo> w = tablas.get("world");
        if (!w.containsKey(id)) {
            addError("[SEM] Llamada a función inexistente: " + id + " (" + line + "," + col + ")");
            return;
        }
        String k = w.get(id).kind;
        if (!"FUNC".equals(k) && !"MAIN".equals(k)) {
            addError("[SEM] Llamada a no-función: " + id + " (" + line + "," + col + ")");
        }
    }

    void checkArray(String id, int line, int col) {
        SymInfo si = lookup(id);
        if (si == null) {
            addError("[SEM] Acceso a arreglo no declarado: " + id + " (" + line + "," + col + ")");
            return;
        }
        if (!"ARR".equals(si.kind)) {
            addError("[SEM] Acceso arreglo sobre símbolo no-arreglo: " + id + " (" + line + "," + col + ")");
        }
    }

    void printTablas() {
        System.out.println("\n---------- TABLAS DE SIMBOLOS----------");
        System.out.println("Scope: world");
        for (Map.Entry<String, SymInfo> e : tablas.get("world").entrySet()) {
            System.out.println("  " + e.getKey() + " -> " + e.getValue());
        }
        System.out.println();

        for (String scope : tablas.keySet()) {
            if ("world".equals(scope)) continue;
            System.out.println("Scope: " + scope + " (parent=" + parentScope.get(scope) + ")");
            for (Map.Entry<String, SymInfo> e : tablas.get(scope).entrySet()) {
                System.out.println("  " + e.getKey() + " -> " + e.getValue());
            }
            System.out.println();
        }

        if (!errores.isEmpty()) {
            System.out.println("---------- ERRORES/AVISOS ----------");
            for (String e : errores) System.out.println(e);
        }
        System.out.println("------------------------------\n");
    }

    /*----------errores sintacticos----------*/
    public void syntax_error(Symbol s) {
        addError("[SINTACTICO] Error de sintaxis en línea " + s.left + " cerca de: " + terminalToString(s));
    }

    public void report_error(String message, Object info) {
        addError("[SINTACTICO] " + message);
    }

    private String terminalToString(Symbol s) {
        try {
            return sym.terminalNames[s.sym] + (s.value != null ? ("('" + s.value + "')") : "");
        } catch(Exception e) {
            return "<?>"; 
        }
    }

:}

init with {: initTablas(); :};


/*
----------TERMINALES----------*/

terminal BLOCK_OPEN, BLOCK_CLOSE, NAVIDAD, GIFT, WORLD, INT, FLOAT, BOOLEAN, CHAR, STRING, LOCAL, COAL_TYPE;
terminal DECIDE, OF, END, ELSE, LOOP, EXIT, WHEN, FOR, BREAK, RETURN;
terminal ARROW, ENDL, ASSIGN, PARENTHESIS_OPEN, PARENTHESIS_CLOSE, ARRAY_OPEN, ARRAY_CLOSE, COMMA;
terminal PLUS, MINUS, TIMES, DIV_INT, DIV, MODULE, POWER;
terminal LESS_OR_EQ_THAN, LESS_THAN, MORE_OR_EQ_THAN, MORE_THAN, EQUALS, DIFFERENT;
terminal AND, OR, NOT;
terminal DECREMENT, INCREMENT;
terminal SHOW, GET;
terminal INT_LIT, FLOAT_LIT, BOOLEAN_LIT, CHAR_LIT, STRING_LIT;
terminal ID;

/*
----------NO TERMINALES----------*/

non terminal programa, funciones, funcion, main;
non terminal tipo, literal, alcance;
non terminal params, params_opt, param;
non terminal creacion, creacion_sentencia, asignacion, asignacion_sentencia;
non terminal reasignacion, reasignacion_sentencia;
non terminal unario;
non terminal sentencias, sentencia, bloque;
non terminal estructura, for_init, for, loop, decide_of;
non terminal casos, caso;
non terminal arreglo, dim, decl_arreglo, creacion_arreglo;
non terminal asignacion_elemento, acceso_arreglo;
non terminal elementos, fila, filas, arreglo_init;
non terminal lit_array;
non terminal llamada, args;
non terminal expresion;
non terminal expr_aritm, term, power, factor;
non terminal expr_relacional, expresion_rel, operador_rel;
non terminal expr_logica, expr_and, expr_not, expr_bool;
non terminal io, show, show_arg, get, get_target;

/*
----------INICIO----------*/

start with programa;

/*
----------PROGRAMA----------*/
programa ::=
      globales funciones main
      {:
          Nodo n = new Nodo("programa");
          n.addHijo((Nodo)$1); // globales
          n.addHijo((Nodo)$2); // funciones
          n.addHijo((Nodo)$3); // main
          raizAST = n;
          System.out.println("Programa reconocido.");
          raizAST.arbol();
          printTablas();
          RESULT = n;
      :}
    | globales main
      {:
          Nodo n = new Nodo("programa");
          n.addHijo((Nodo)$1); // globales
          n.addHijo((Nodo)$2); // main
          raizAST = n;
          System.out.println("Programa reconocido.");
          raizAST.arbol();
          printTablas();
          RESULT = n;
      :}
    | funciones main
      {:
          Nodo n = new Nodo("programa");
          n.addHijo((Nodo)$1);
          n.addHijo((Nodo)$2);
          raizAST = n;
          System.out.println("Programa reconocido.");
          raizAST.arbol();
          printTablas();
          RESULT = n;
      :}
    | main
      {:
          Nodo n = new Nodo("programa");
          n.addHijo((Nodo)$1);
          raizAST = n;
          System.out.println("Programa reconocido.");
          raizAST.arbol();
          printTablas();
          RESULT = n;
      :}
    ;
    
funciones ::=
      funciones:fs funcion:fn
      {:
          Nodo n = (Nodo)fs;
          n.addHijo((Nodo)fn);
          RESULT = n;
      :}
    | funcion:fn
      {:
          Nodo n = new Nodo("funciones");
          n.addHijo((Nodo)fn);
          RESULT = n;
      :}
    ;

/*
----------FUNCIONES----------*/
funciones ::= 
            funciones:fs funcion:fn
            {: 
                    Nodo n = (Nodo)fs;
                    n.addHijo((Nodo)fn);
                    RESULT = n;
            :}
        | funcion:fn
            {: 
                    Nodo n = new Nodo("funciones");
                    n.addHijo((Nodo)fn);
                    RESULT = n;
            :}
        ;

/*
----------DATOS----------*/

// tipo
tipo ::= 
            INT {:Nodo n=new Nodo("int");     n.setTipo("int");     RESULT=n; :}
        | FLOAT {:Nodo n=new Nodo("float");   n.setTipo("float");   RESULT=n; :}
        | BOOLEAN {:Nodo n=new Nodo("boolean"); n.setTipo("boolean"); RESULT=n; :}
        | CHAR {:Nodo n=new Nodo("char");    n.setTipo("char");    RESULT=n; :}
        | STRING {:Nodo n=new Nodo("string");  n.setTipo("string");  RESULT=n; :}
        ;

// literal
literal ::= 
            INT_LIT:i {: Nodo n=new Nodo(i); n.setTipo("int"); RESULT=n; :}
        | FLOAT_LIT:f {: Nodo n=new Nodo(f); n.setTipo("float"); RESULT=n; :}
        | BOOLEAN_LIT:b {: Nodo n=new Nodo(b); n.setTipo("boolean"); RESULT=n; :}
        | CHAR_LIT:c {: Nodo n=new Nodo(c); n.setTipo("char"); RESULT=n; :}
        | STRING_LIT:s {: Nodo n=new Nodo(s); n.setTipo("string"); RESULT=n; :}
        ;



// alcance
alcance ::= 
            WORLD
            {: Nodo n = new Nodo("world"); n.setTipo("world"); RESULT = n; :}
        | LOCAL
            {: Nodo n = new Nodo("local"); n.setTipo("local"); RESULT = n; :}
        ;

/*
----------FUNCIONES----------
*/

// params_opt
params_opt ::= 
            params:p {: RESULT=(Nodo)p; :}
        | /* empty */ {: RESULT=new Nodo("params_vacios"); :}
        ;

// params
params ::= 
            params:ps COMMA param:p
            {: 
                    Nodo n=(Nodo)ps;
                    n.addHijo(new Nodo(","));
                    n.addHijo((Nodo)p);
                    RESULT=n;
            :}
        | param:p
            {: 
                    Nodo n=new Nodo("params");
                    n.addHijo((Nodo)p);
                    RESULT=n;
            :}
        ;

param ::= 
      tipo:t ID:id
      {: 
          String idStr = id.toString();
          declareVar("local", ((Nodo)t).getTipo(), idStr, idleft, idright, true);

          Nodo n=new Nodo("param");
          n.addHijo((Nodo)t);
          Nodo nid=new Nodo(idStr); nid.setTipo(((Nodo)t).getTipo());
          n.addHijo(nid);
          RESULT=n;
      :}
    ;

/*
----------MAIN----------*/
main ::= 
      COAL_TYPE NAVIDAD:nav
      {: 
          declareMain(navleft, navright); 
          pushNamedScope("navidad"); 
      :}
      PARENTHESIS_OPEN PARENTHESIS_CLOSE bloque:b
      {: 
          Nodo n=new Nodo("main");
          n.addHijo(new Nodo("coal"));
          n.addHijo(new Nodo("navidad"));
          n.addHijo((Nodo)b);

          popScope();

          RESULT=n;
      :}
    ;

/*
----------FUNCION----------*/
funcion ::= 
      GIFT tipo:t ID:id
      {: 
          String idStr = id.toString();
          declareFunc(idStr, ((Nodo)t).getTipo(), idleft, idright);
          pushNamedScope(idStr);
      :}
      PARENTHESIS_OPEN params_opt:po PARENTHESIS_CLOSE bloque:b
      {: 
          String idStr = id.toString();
          Nodo n=new Nodo("funcion");
          n.addHijo(new Nodo("gift"));
          Nodo nid=new Nodo(idStr); nid.setTipo(((Nodo)t).getTipo());
          n.addHijo((Nodo)t);
          n.addHijo(nid);
          n.addHijo((Nodo)po);
          n.addHijo((Nodo)b);

          popScope();

          RESULT=n;
      :}
    ;

/*
----------DECLARACIONES----------*/

// creacion
creacion ::= 
      alcance:a tipo:t ID:id
      {: 
          String alc = ((Nodo)a).getTipo();
          String idStr = id.toString();
          declareVar(alc, ((Nodo)t).getTipo(), idStr, idleft, idright, false);

          Nodo n=new Nodo("creacion");
          n.addHijo((Nodo)a);
          Nodo nid=new Nodo(idStr); nid.setTipo(((Nodo)t).getTipo());
          n.addHijo((Nodo)t);
          n.addHijo(nid);
          RESULT=n;
      :}
    ;

// creacion_sentencia
creacion_sentencia ::= 
      creacion:c ENDL
      {: 
          Nodo n=new Nodo("creacion_sent");
          n.addHijo((Nodo)c);
          RESULT=n;
      :}
    ;

// asignacion
asignacion ::= 
      alcance:a tipo:t ID:id ASSIGN expresion:e
      {: 
          String alc=((Nodo)a).getTipo();
          String idStr = id.toString();
          declareVar(alc, ((Nodo)t).getTipo(), idStr, idleft, idright, false);

          Nodo n=new Nodo("asignacion_decl");
          n.addHijo((Nodo)a);
          Nodo nid=new Nodo(idStr); nid.setTipo(((Nodo)t).getTipo());
          n.addHijo((Nodo)t);
          n.addHijo(nid);
          n.addHijo(new Nodo("="));
          n.addHijo((Nodo)e);
          RESULT=n;
      :}
    ;

// reasignacion
reasignacion ::= 
      ID:id ASSIGN expresion:e
      {: 
          String idStr = id.toString();
          checkID(idStr, idleft, idright); // Verificar si existe
          Nodo n=new Nodo("reasignacion");
          Nodo nid=new Nodo(idStr);
          n.addHijo(nid);
          n.addHijo(new Nodo("="));
          n.addHijo((Nodo)e);
          RESULT=n;
      :}
    ;

// reasignacion_sentencia
reasignacion_sentencia ::= 
      reasignacion:r ENDL
      {: 
          Nodo n=new Nodo("reasignacion_sent");
          n.addHijo((Nodo)r);
          RESULT=n;
      :}
    ;

// asignacion_sentencia
asignacion_sentencia ::= 
      asignacion:a ENDL
      {: 
          Nodo n=new Nodo("asignacion_sent");
          n.addHijo((Nodo)a);
          RESULT=n;
      :}
    ;

// unario
unario ::= INCREMENT ID:id
                 {: Nodo n = new Nodo("++pre"); Nodo idn = new Nodo((String)id); n.addHijo(idn); RESULT = n; :}
             | DECREMENT ID:id
                 {: Nodo n = new Nodo("--pre"); Nodo idn = new Nodo((String)id); n.addHijo(idn); RESULT = n; :}
             | ID:id INCREMENT
                 {: Nodo n = new Nodo("++post"); Nodo idn = new Nodo((String)id); n.addHijo(idn); RESULT = n; :}
             | ID:id DECREMENT
                 {: Nodo n = new Nodo("--post"); Nodo idn = new Nodo((String)id); n.addHijo(idn); RESULT = n; :}
             | INCREMENT acceso_arreglo:a
                 {: Nodo n = new Nodo("++pre"); n.addHijo((Nodo)a); RESULT = n; :}
             | DECREMENT acceso_arreglo:a
                 {: Nodo n = new Nodo("--pre"); n.addHijo((Nodo)a); RESULT = n; :}
             | acceso_arreglo:a INCREMENT
                 {: Nodo n = new Nodo("++post"); n.addHijo((Nodo)a); RESULT = n; :}
             | acceso_arreglo:a DECREMENT
                 {: Nodo n = new Nodo("--post"); n.addHijo((Nodo)a); RESULT = n; :}
             ;

/*
----------SENTENCIAS----------
*/

// sentencias
sentencias ::= 
            sentencias:ss sentencia:s
            {: 
                    Nodo n=(Nodo)ss;
                    n.addHijo((Nodo)s);
                    RESULT=n;
            :}
        | sentencia:s
            {: 
                    Nodo n=new Nodo("sentencias");
                    n.addHijo((Nodo)s);
                    RESULT=n;
            :}
        ;
    
/*
----------SENTENCIA----------
*/

sentencia ::=
      asignacion_sentencia:a {: RESULT = a; :}
    | reasignacion_sentencia:r {: RESULT = r; :}
    | creacion_sentencia:c {: RESULT = c; :}
    | estructura:e {: RESULT = e; :}
    | expresion:e ENDL
      {:
          Nodo n=new Nodo("expr_sent");
          n.addHijo((Nodo)e);
          RESULT=n;
      :}
    | asignacion_elemento:a {: RESULT = a; :}
    | io:i {: RESULT = i; :}
    | BREAK ENDL
      {:
          Nodo n=new Nodo("break");
          RESULT=n;
      :}
    | RETURN expresion:e ENDL
      {:
          Nodo n=new Nodo("return");
          n.addHijo((Nodo)e);
          RESULT=n;
      :}
    | error ENDL
      {:
          addError("[PANIC] Sentencia inválida, sincronizado en ENDL.");
          RESULT=new Nodo("sentencia_error");
      :}
    ;

// BLOQUE
bloque ::=
      BLOCK_OPEN sentencias:s BLOCK_CLOSE
      {:
          Nodo n=new Nodo("bloque");
          n.addHijo(new Nodo("¡"));
          n.addHijo((Nodo)s);
          n.addHijo(new Nodo("!"));
          RESULT=n;
      :}
    | BLOCK_OPEN BLOCK_CLOSE
      {:
          Nodo n=new Nodo("bloque_vacio");
          n.addHijo(new Nodo("¡"));
          n.addHijo(new Nodo("!"));
          RESULT=n;
      :}
    | BLOCK_OPEN error BLOCK_CLOSE
      {:
          addError("[PANIC] Bloque inválido, sincronizado en '!'.");
          RESULT=new Nodo("bloque_error");
      :}
    ;

/*
----------CONTROL----------*/
estructura ::=
      for:f {: RESULT = f; :}
    | loop:l {: RESULT = l; :}
    | decide_of:d {: RESULT = d; :}
    | arreglo:a {: RESULT = a; :}
    ;

// for_init
for_init ::=
      asignacion:a {: RESULT = a; :}
    | creacion:c {: RESULT = c; :}
    | reasignacion:r {: RESULT = r; :}
    ;

// FOR
for ::=
      FOR PARENTHESIS_OPEN for_init:fi ENDL expr_logica:cond ENDL unario:u PARENTHESIS_CLOSE bloque:b ENDL
      {:
          Nodo n=new Nodo("for");
          n.addHijo((Nodo)fi);
          n.addHijo((Nodo)cond);
          n.addHijo((Nodo)u);
          n.addHijo((Nodo)b);
          RESULT=n;
      :}
    ;

// LOOP
loop ::=
      LOOP sentencias:s EXIT WHEN expr_logica:cond ENDL END LOOP ENDL
      {:
          Nodo n=new Nodo("loop");
          n.addHijo((Nodo)s);
          n.addHijo((Nodo)cond);
          RESULT=n;
      :}
    ;

casos ::=
      casos:cs caso:c
      {:
          Nodo n=(Nodo)cs;
          n.addHijo((Nodo)c);
          RESULT=n;
      :}
    | caso:c
      {:
          Nodo n=new Nodo("casos");
          n.addHijo((Nodo)c);
          RESULT=n;
      :}
    ;

caso ::=
      expr_logica:cond ARROW bloque:b
      {:
          Nodo n=new Nodo("caso");
          n.addHijo((Nodo)cond);
          n.addHijo((Nodo)b);
          RESULT=n;
      :}
    ;

// DECIDE OF
decide_of ::=
      DECIDE OF casos:cs END DECIDE ENDL
      {:
          Nodo n=new Nodo("decide_of");
          n.addHijo((Nodo)cs);
          RESULT=n;
      :}
    | DECIDE OF casos:cs ELSE bloque:b END DECIDE ENDL
      {:
          Nodo n=new Nodo("decide_of");
          n.addHijo((Nodo)cs);
          n.addHijo((Nodo)b);
          RESULT=n;
      :}
    ;

/*----------ARREGLOS----------
*/

arreglo ::= creacion_arreglo:c {: RESULT = c; :}
    ;
  

dim ::= ARRAY_OPEN INT_LIT:d1 ARRAY_CLOSE ARRAY_OPEN INT_LIT:d2 ARRAY_CLOSE
    {: Nodo n = new Nodo("dim"); Nodo n1 = new Nodo(d1); Nodo n2 = new Nodo(d2); n.addHijo(n1); n.addHijo(n2); RESULT = n; :}
    ;

decl_arreglo ::= tipo:t ID:id dim:dm
    {: Nodo n = new Nodo("decl_arreglo"); n.addHijo((Nodo)t); Nodo nid = new Nodo(id); n.addHijo(nid); n.addHijo((Nodo)dm); RESULT = n; :}
    ;

creacion_arreglo ::= 
      alcance:a decl_arreglo:d ENDL
        {: Nodo n = new Nodo("creacion_arreglo"); n.addHijo((Nodo)a); n.addHijo((Nodo)d); RESULT = n; :}
    | alcance:a decl_arreglo:d ASSIGN arreglo_init:init ENDL
        {: Nodo n = new Nodo("creacion_arreglo_init"); n.addHijo((Nodo)a); n.addHijo((Nodo)d); n.addHijo((Nodo)init); RESULT = n; :}
    ;

asignacion_elemento ::= acceso_arreglo:a ASSIGN lit_array:l ENDL
    {: Nodo n = new Nodo("asignacion_elemento"); n.addHijo((Nodo)a); n.addHijo((Nodo)l); RESULT = n; :}
    ;

acceso_arreglo ::= ID:id ARRAY_OPEN expresion:e1 ARRAY_CLOSE ARRAY_OPEN expresion:e2 ARRAY_CLOSE
    {: Nodo n = new Nodo("acceso_arreglo"); Nodo nid = new Nodo(id); n.addHijo(nid); n.addHijo((Nodo)e1); n.addHijo((Nodo)e2); RESULT = n; :}
    ;

elementos ::= lit_array:l
    {: Nodo n = new Nodo("elementos"); n.addHijo((Nodo)l); RESULT = n; :}
    | elementos:els COMMA lit_array:l
    {: Nodo n = (Nodo)els; n.addHijo(new Nodo(",")); n.addHijo((Nodo)l); RESULT = n; :}
    ;

fila ::= BLOCK_OPEN elementos:els BLOCK_CLOSE
    {: Nodo n = new Nodo("fila"); n.addHijo((Nodo)els); RESULT = n; :}
    ;

filas ::= fila:f
    {: Nodo n = new Nodo("filas"); n.addHijo((Nodo)f); RESULT = n; :}
    | filas:fs COMMA fila:f
    {: Nodo n = (Nodo)fs; n.addHijo(new Nodo(",")); n.addHijo((Nodo)f); RESULT = n; :}
    ;

arreglo_init ::= BLOCK_OPEN filas:f BLOCK_CLOSE
    {: Nodo n = new Nodo("arreglo_init"); n.addHijo((Nodo)f); RESULT = n; :}
    ;


lit_array ::= INT_LIT:i {: Nodo n = new Nodo(i); n.setTipo("int"); RESULT = n; :}
           | CHAR_LIT:c {: Nodo n = new Nodo(c); n.setTipo("char"); RESULT = n; :}
           ;

/*
----------LLAMADAS A FUNCIONES----------
*/

llamada ::= ID:id PARENTHESIS_OPEN args:a PARENTHESIS_CLOSE
        {: Nodo n = new Nodo("llamada"); Nodo nid = new Nodo(id); n.addHijo(nid); n.addHijo((Nodo)a); RESULT = n; :}
    | ID:id PARENTHESIS_OPEN PARENTHESIS_CLOSE
        {: Nodo n = new Nodo("llamada"); Nodo nid = new Nodo(id); n.addHijo(nid); RESULT = n; :}
          ;

args ::= args:as COMMA expresion:e
        {: Nodo n = (Nodo)as; n.addHijo(new Nodo(",")); n.addHijo((Nodo)e); RESULT = n; :}
    | expresion:e
        {: Nodo n = new Nodo("args"); n.addHijo((Nodo)e); RESULT = n; :}
    ;

/*
----------EXPRESIONES----------
*/

expresion ::= expr_logica:e {: RESULT = e; :}
            ;

// ARITMÉTICAS

expr_aritm ::= expr_aritm:e1 PLUS term:e2
        {: Nodo n = new Nodo("+"); n.addHijo((Nodo)e1); n.addHijo((Nodo)e2); RESULT = n; :}
    | expr_aritm:e1 MINUS term:e2
        {: Nodo n = new Nodo("-"); n.addHijo((Nodo)e1); n.addHijo((Nodo)e2); RESULT = n; :}
    | term:t
        {: RESULT = t; :}
    ;

term ::= term:t1 TIMES power:t2
        {: Nodo n = new Nodo("*"); n.addHijo((Nodo)t1); n.addHijo((Nodo)t2); RESULT = n; :}
    | term:t1 DIV power:t2
        {: Nodo n = new Nodo("/"); n.addHijo((Nodo)t1); n.addHijo((Nodo)t2); RESULT = n; :}
    | term:t1 DIV_INT power:t2
        {: Nodo n = new Nodo("//"); n.addHijo((Nodo)t1); n.addHijo((Nodo)t2); RESULT = n; :}
    | term:t1 MODULE power:t2
        {: Nodo n = new Nodo("%"); n.addHijo((Nodo)t1); n.addHijo((Nodo)t2); RESULT = n; :}
    | power:p
        {: RESULT = p; :}
    ;

power ::= factor:f1 POWER power:f2
        {: Nodo n = new Nodo("^"); n.addHijo((Nodo)f1); n.addHijo((Nodo)f2); RESULT = n; :}
    | factor:f
        {: RESULT = f; :}
    ;

factor ::= literal:l
        {: RESULT = l; :}
    | ID:id
        {: Nodo n = new Nodo(id); RESULT = n; :}
    | acceso_arreglo:a
        {: RESULT = a; :}
    | llamada:ll
        {: RESULT = ll; :}
    | MINUS factor:f
        {: Nodo n = new Nodo("neg"); n.addHijo((Nodo)f); RESULT = n; :}
    | unario:u
        {: RESULT = u; :}
    | PARENTHESIS_OPEN expresion:e PARENTHESIS_CLOSE
        {: RESULT = e; :}
    ;

// RELACIONALES

expr_relacional ::= expresion_rel:e1 operador_rel:op expresion_rel:e2
    {: Nodo n = new Nodo(op); n.addHijo((Nodo)e1); n.addHijo((Nodo)e2); RESULT = n; :}
    ;

expresion_rel ::= expr_aritm:e {: RESULT = e; :}
                ;

operador_rel ::= LESS_THAN      {: RESULT = "<"; :}
              | LESS_OR_EQ_THAN {: RESULT = "<="; :}
              | MORE_THAN      {: RESULT = ">"; :}
              | MORE_OR_EQ_THAN {: RESULT = ">="; :}
              | EQUALS         {: RESULT = "=="; :}
              | DIFFERENT      {: RESULT = "!="; :}
              ;

// LOGICAS:

expr_logica ::= expr_logica:e1 OR expr_and:e2
        {: Nodo n = new Nodo("or"); n.addHijo((Nodo)e1); n.addHijo((Nodo)e2); RESULT = n; :}
    | expr_and:e
        {: RESULT = e; :}
    ;

expr_and ::= expr_and:e1 AND expr_not:e2
        {: Nodo n = new Nodo("and"); n.addHijo((Nodo)e1); n.addHijo((Nodo)e2); RESULT = n; :}
    | expr_not:e
        {: RESULT = e; :}
    ;

expr_not ::= NOT expr_not:e
        {: Nodo n = new Nodo("not"); n.addHijo((Nodo)e); RESULT = n; :}
    | expr_bool:e
        {: RESULT = e; :}
    ;

expr_bool ::= expr_relacional:e
        {: RESULT = e; :}
    | expr_aritm:e
        {: RESULT = e; :}
    | PARENTHESIS_OPEN expr_logica:e PARENTHESIS_CLOSE
        {: RESULT = e; :}
    ;

/* -----I/O----- */

io ::= show:s {: RESULT = s; :}
    | get:g {: RESULT = g; :}
    ;

show ::= SHOW PARENTHESIS_OPEN show_arg:a PARENTHESIS_CLOSE ENDL
    {: Nodo n = new Nodo("show"); n.addHijo((Nodo)a); RESULT = n; :}
    ;

show_arg ::= literal:l {: RESULT = l; :}
         | ID:id {: Nodo n = new Nodo(id); RESULT = n; :}
         | acceso_arreglo:a {: RESULT = a; :}
         ;

get ::= GET PARENTHESIS_OPEN get_target:t PARENTHESIS_CLOSE ENDL
    {: Nodo n = new Nodo("get"); n.addHijo((Nodo)t); RESULT = n; :}
    ;

get_target ::= ID:id {: Nodo n = new Nodo(id); RESULT = n; :}
           | acceso_arreglo:a {: RESULT = a; :}
           ;

