import java_cup.runtime.*;
import java.util.*;

// Conectar CUP con el lexer generado por JFlex
scan with {: return ((Lexer)getScanner()).next_token(); :};

/* ---------- TABLA DE SIMBOLOS ---------- */

parser code {:
    public Nodo raizAST = null;

    
    static class SymInfo {
        // clase para almacenar info de simbolos en la tabla
        String kind;      // VAR, ARR, PARAM, FUNC, MAIN
        String type;      // int/float/boolean/char/string/coal
        Integer dim1;     // para arreglos
        Integer dim2;     // para arreglos
        int line, col;

        SymInfo(String kind, String type, int line, int col) {
            this.kind = kind;
            this.type = type;
            this.line = line;
            this.col = col;
        }

        // Constructores para arreglos
        SymInfo(String kind, String type, int dim1, int dim2, int line, int col) {
            this.kind = kind;
            this.type = type;
            this.dim1 = dim1;
            this.dim2 = dim2;
            this.line = line;
            this.col = col;
        }

        @Override
        public String toString() {
            if (dim1 != null && dim2 != null) {
                return kind + " : " + type + "[" + dim1 + "][" + dim2 + "]" + " (" + line + "," + col + ")";
            }
            return kind + " : " + type + " (" + line + "," + col + ")";
        }
    }

    // ---------- estructuras para scopes y tabla de simbolos ----------

    // Mapa: nombre de scope -> (id -> SymInfo)
    HashMap<String, HashMap<String, SymInfo>> tablas = new HashMap<>();

    // Mapa: nombre de scope -> nombre del scope padre
    HashMap<String, String> parentScope = new HashMap<>();

    // Contador para generar nombres únicos de scopes anidados
    HashMap<String, Integer> counters = new HashMap<>();

    // Pila de scopes activos (jerarquía actual)
    Deque<String> scopeStack = new ArrayDeque<>();

    // Lista de errores semánticos y sintácticos encontrados
    ArrayList<String> errores = new ArrayList<>();

    /**
     * Inicializa la tabla de símbolos global y el scope "world".
     */
    void initTablas() {
        tablas.put("world", new HashMap<>());
        parentScope.put("world", null);
        scopeStack.clear();
        scopeStack.push("world");
    }

    /**
     * Obtiene el nombre del scope actual
     */
    String currentScope() {
        return scopeStack.peek();
    }

    /**
     * Genera un nombre único para un nuevo scope hijo, basado en el scope actual y el tipo de bloque.
     * @param kind Tipo de bloque (ej: for, bloque, etc)
     * @return Nombre único de scope
     */
    String genScopeName(String kind) {
        String parent = currentScope();
        String key = parent + "#" + kind;
        int n = counters.getOrDefault(key, 0) + 1;
        counters.put(key, n);
        return parent + "_" + kind + n; 
    }

    /**
     * Entra a un scope nombrado 
     * @param name Nombre del nuevo scope
     */
    void pushNamedScope(String name) {
        if (!tablas.containsKey(name)) tablas.put(name, new HashMap<>());
        if (!parentScope.containsKey(name)) parentScope.put(name, currentScope()); // si no tiene padre, se le pone el current
        scopeStack.push(name);
    }

    /**
     * Entra a un scope nuevo y le genera un nombre unico según el tipo
     * @param kind Tipo de bloque
     */
    void pushAutoScope(String kind) {
        pushNamedScope(genScopeName(kind));
    }

    // Sale del scope actual
    void popScope() {
        if (scopeStack.size() > 1) scopeStack.pop();
    }
    
    void addError(String msg) {
        errores.add(msg);
        System.err.println(msg);
    }

    /* Visibilidad hacia arriba:
    busca una expresion o funcion siguiendo la jerarquia de scopes
    Si el simbolo no está en el current, sube al papa, y asi hasta encontrarlo o llegar a world y poner null
    
     */
    SymInfo lookup(String id) {
        String s = currentScope();
        while (s != null) {
            HashMap<String, SymInfo> t = tablas.get(s);
            if (t != null && t.containsKey(id)) return t.get(id);
            s = parentScope.get(s); // Sube al tata
        }
        return null;
    }
    // Revisa si el ID ya existe en el scope actual para detectar duplicados
    boolean existsInCurrent(String id) {
        return tablas.get(currentScope()).containsKey(id);
    }

    // Verifica que un identificador exista 
    void checkID(String id, int line, int col) {
        if (lookup(id) == null) {
            addError("[SEM] Uso de ID no declarado: " + id + " (" + line + "," + col + ")");
        }
    }

    // Declara un símbolo en un scope específico
    void declareInScope(String scope, String id, SymInfo info) {
        HashMap<String, SymInfo> t = tablas.get(scope);
        if (t.containsKey(id)) {
            addError("[SEM] Duplicado en scope '" + scope + "': " + id + " (" + info.line + "," + info.col + ")");
            return;
        }
        t.put(id, info);
    }

    // Declara variables o parametros y los mete a la tabla que corresponda
    void declareVar(String alcance, String tipo, String id, int line, int col, boolean isParam) {
        if ("world".equals(alcance)) {
            declareInScope("world", id, new SymInfo(isParam ? "PARAM" : "VAR", tipo, line, col));
            return;
        }
        // local
        if ("world".equals(currentScope())) {
            addError("[SEM] 'local' fuera de función/navidad/bloque: " + id + " (" + line + "," + col + ")");
            return;
        }
        declareInScope(currentScope(), id, new SymInfo(isParam ? "PARAM" : "VAR", tipo, line, col));
    }

    // Igual que declareVar pero para arrays
    void declareArr(String alcance, String tipo, String id, int d1, int d2, int line, int col) {
        if ("world".equals(alcance)) {
            declareInScope("world", id, new SymInfo("ARR", tipo, d1, d2, line, col));
            return;
        }
        if ("world".equals(currentScope())) {
            addError("[SEM] 'local' fuera de función/navidad/bloque (arreglo): " + id + " (" + line + "," + col + ")");
            return;
        }
        declareInScope(currentScope(), id, new SymInfo("ARR", tipo, d1, d2, line, col));
    }

    // Declara una función en world
    void declareFunc(String id, String tipoRet, int line, int col) {
        HashMap<String, SymInfo> w = tablas.get("world");
        if (w.containsKey(id)) {
            addError("[SEM] Duplicado global en world: " + id + " (" + line + "," + col + ")");
            return;
        }
        w.put(id, new SymInfo("FUNC", tipoRet, line, col));
    }

    // Declara el main navidad en world
    void declareMain(int line, int col) {
        HashMap<String, SymInfo> w = tablas.get("world");
        if (w.containsKey("navidad")) {
            addError("[SEM] Duplicado main navidad (" + line + "," + col + ")");
            return;
        }
        w.put("navidad", new SymInfo("MAIN", "coal", line, col));
    }

    void checkCall(String id, int line, int col) {
        HashMap<String, SymInfo> w = tablas.get("world");
        if (!w.containsKey(id)) {
            addError("[SEM] Llamada a función inexistente: " + id + " (" + line + "," + col + ")");
            return;
        }
        String k = w.get(id).kind;
        if (!"FUNC".equals(k) && !"MAIN".equals(k)) {
            addError("[SEM] Llamada a no-función: " + id + " (" + line + "," + col + ")");
        }
    }

    void checkArray(String id, int line, int col) {
        SymInfo si = lookup(id);
        if (si == null) {
            addError("[SEM] Acceso a arreglo no declarado: " + id + " (" + line + "," + col + ")");
            return;
        }
        if (!"ARR".equals(si.kind)) {
            addError("[SEM] Acceso arreglo sobre símbolo no-arreglo: " + id + " (" + line + "," + col + ")");
        }
    }

    /* ---------- ANÁLISIS SEMÁNTICO DE TIPOS ---------- */

    // Tipo especial para errores (evita efecto cascada)
    static final String ERROR_TYPE = "error";

    // Verifica compatibilidad de tipos para operaciones aritméticas
    String checkArithmetic(String t1, String t2, String op, int line, int col) {
        if (ERROR_TYPE.equals(t1) || ERROR_TYPE.equals(t2)) return ERROR_TYPE;
        if (t1 == null || t2 == null || t1.isEmpty() || t2.isEmpty()) return ERROR_TYPE;

        // int con int -> int
        if ("int".equals(t1) && "int".equals(t2)) return "int";
        // float con float -> float
        if ("float".equals(t1) && "float".equals(t2)) return "float";
        // int con float o float con int -> float (promoción)
        if (("int".equals(t1) && "float".equals(t2)) ||
            ("float".equals(t1) && "int".equals(t2))) return "float";

        addError("[SEM] Tipos incompatibles para '" + op + "': " + t1 + " y " + t2 + " (" + line + "," + col + ")");
        return ERROR_TYPE;
    }

    // Verifica que los operandos de comparación sean compatibles
    String checkRelational(String t1, String t2, String op, int line, int col) {
        if (ERROR_TYPE.equals(t1) || ERROR_TYPE.equals(t2)) return "boolean";
        if (t1 == null || t2 == null || t1.isEmpty() || t2.isEmpty()) return "boolean";

        boolean t1Num = "int".equals(t1) || "float".equals(t1);
        boolean t2Num = "int".equals(t2) || "float".equals(t2);

        if (t1Num && t2Num) return "boolean";

        // Igualdad permite cualquier tipo compatible
        if ("==".equals(op) || "!=".equals(op)) {
            if (t1.equals(t2)) return "boolean";
        }

        addError("[SEM] Tipos incompatibles para '" + op + "': " + t1 + " y " + t2 + " (" + line + "," + col + ")");
        return "boolean";
    }

    // Verifica que el tipo sea booleano (para AND, OR, NOT)
    String checkBoolean(String t, String op, int line, int col) {
        if (ERROR_TYPE.equals(t)) return ERROR_TYPE;
        if (t == null || t.isEmpty()) return ERROR_TYPE;
        if ("boolean".equals(t)) return "boolean";
        addError("[SEM] Se esperaba boolean para '" + op + "', encontrado: " + t + " (" + line + "," + col + ")");
        return ERROR_TYPE;
    }

    // Verifica asignación: que el tipo de la expresión sea compatible con el tipo de la variable
    void checkAssignment(String varType, String exprType, String id, int line, int col) {
        if (ERROR_TYPE.equals(exprType)) return; // Ya hubo error
        if (varType == null || exprType == null || varType.isEmpty() || exprType.isEmpty()) return;

        if (varType.equals(exprType)) return; // Tipos iguales OK

        // Permitir int -> float (promoción)
        if ("float".equals(varType) && "int".equals(exprType)) return;

        addError("[SEM] Tipo incompatible en asignación a '" + id + "': esperaba " + varType + ", encontrado " + exprType + " (" + line + "," + col + ")");
    }

    // Verifica que el índice de arreglo sea int
    void checkArrayIndex(String indexType, int line, int col) {
        if (ERROR_TYPE.equals(indexType)) return;
        if (indexType == null || indexType.isEmpty()) return;
        if (!"int".equals(indexType)) {
            addError("[SEM] Índice de arreglo debe ser int, encontrado: " + indexType + " (" + line + "," + col + ")");
        }
    }

    // Obtiene el tipo de un ID desde la tabla de símbolos
    String getIdType(String id, int line, int col) {
        SymInfo info = lookup(id);
        if (info == null) {
            return ERROR_TYPE;
        }
        return info.type;
    }

    // Obtiene el tipo de retorno de una función
    String getFuncReturnType(String id) {
        HashMap<String, SymInfo> w = tablas.get("world");
        SymInfo info = w.get(id);
        if (info == null) return ERROR_TYPE;
        return info.type;
    }

    // Verifica tipos para incremento/decremento
    String checkUnary(String t, String op, int line, int col) {
        if (ERROR_TYPE.equals(t)) return ERROR_TYPE;
        if (t == null || t.isEmpty()) return ERROR_TYPE;
        if ("int".equals(t) || "float".equals(t)) return t;
        addError("[SEM] '" + op + "' requiere tipo numérico, encontrado: " + t + " (" + line + "," + col + ")");
        return ERROR_TYPE;
    }

    void printTablas() {
        System.out.println("\n---------- TABLAS DE SIMBOLOS----------");
        System.out.println("Scope: world");
        for (Map.Entry<String, SymInfo> e : tablas.get("world").entrySet()) {
            System.out.println("  " + e.getKey() + " -> " + e.getValue());
        }
        System.out.println();

        for (String scope : tablas.keySet()) {
            if ("world".equals(scope)) continue;
            System.out.println("Scope: " + scope + " (parent=" + parentScope.get(scope) + ")");
            for (Map.Entry<String, SymInfo> e : tablas.get(scope).entrySet()) {
                System.out.println("  " + e.getKey() + " -> " + e.getValue());
            }
            System.out.println();
        }

        if (!errores.isEmpty()) {
            System.out.println("---------- ERRORES/AVISOS ----------");
            for (String e : errores) System.out.println(e);
        }
        System.out.println("------------------------------\n");
    }

    /* ---------- GENERACIÓN DE CÓDIGO C3D ---------- */

    // Buffer para acumular código de tres direcciones
    StringBuilder cod3D = new StringBuilder();

    public String getCod3D() {
        return cod3D.toString();
    }

    // Contador de temporales (t1, t2, t3...)
    int tempCount = 0;

    // Contador de etiquetas (L1, L2, L3...)
    int labelCount = 0;

    // Pila de etiquetas para estructuras de control anidadas
    Deque<String> loopStartLabels = new ArrayDeque<>();
    Deque<String> loopEndLabels = new ArrayDeque<>();

    // Genera un nuevo temporal único
    String newTemp() {
        return "t" + (++tempCount);
    }

    // Genera una nueva etiqueta única
    String newLabel() {
        return "L" + (++labelCount);
    }

    // Emite una instrucción al buffer C3D
    void emit(String instruccion) {
        cod3D.append(instruccion).append("\n");
    }

    // Imprime el código C3D generado
    void printC3D() {
        System.out.println("\n---------- CÓDIGO DE TRES DIRECCIONES ----------");
        System.out.println(cod3D.toString());
        System.out.println("-------------------------------------------------\n");
    }

    /*----------errores sintacticos----------*/
    public void syntax_error(Symbol s) {
        addError("[SINTACTICO] Error de sintaxis en línea " + s.left + " cerca de: " + terminalToString(s));
    }
    //“cerca de” = el token con el que el parser se dio cuenta de que ya no puede continuar.

    public void report_error(String message, Object info) {
        addError("[SINTACTICO] " + message);
    }

    private String terminalToString(Symbol s) {
        try {
            return sym.terminalNames[s.sym] + (s.value != null ? ("('" + s.value + "')") : "");
        } catch(Exception e) {
            return "<?>"; 
        }
    }

:}

init with {: initTablas(); :};


/*
----------TERMINALES----------*/

terminal BLOCK_OPEN, BLOCK_CLOSE, NAVIDAD, GIFT, WORLD, INT, FLOAT, BOOLEAN, CHAR, STRING, LOCAL, COAL_TYPE;
terminal DECIDE, OF, END, ELSE, LOOP, EXIT, WHEN, FOR, BREAK, RETURN;
terminal ARROW, ENDL, ASSIGN, PARENTHESIS_OPEN, PARENTHESIS_CLOSE, ARRAY_OPEN, ARRAY_CLOSE, COMMA;
terminal PLUS, MINUS, TIMES, DIV_INT, DIV, MODULE, POWER;
terminal LESS_OR_EQ_THAN, LESS_THAN, MORE_OR_EQ_THAN, MORE_THAN, EQUALS, DIFFERENT;
terminal AND, OR, NOT;
terminal DECREMENT, INCREMENT;
terminal SHOW, GET;
terminal INT_LIT, FLOAT_LIT, BOOLEAN_LIT, CHAR_LIT, STRING_LIT;
terminal ID;

/*
----------NO TERMINALES----------*/

non terminal programa, funcion, main, decl_global, declaraciones_top, decl_top;
non terminal tipo, literal, alcance;
non terminal params, params_opt, param;
non terminal creacion, creacion_sentencia, asignacion, asignacion_sentencia;
non terminal reasignacion, reasignacion_sentencia;
non terminal unario;
non terminal sentencias, sentencia, bloque;
non terminal estructura, for_init, for, loop, decide_of;
non terminal casos, caso;
non terminal dim, decl_arreglo, creacion_arreglo;
non terminal asignacion_elemento, acceso_arreglo;
non terminal elementos, fila, filas, arreglo_init;
non terminal llamada, args;
non terminal expresion;
non terminal expr_aritm, term, power, factor;
non terminal expr_relacional, expresion_rel, operador_rel;
non terminal expr_logica, expr_and, expr_not, expr_bool;
non terminal loop_start, for_start, main_start;
non terminal io, show, show_arg, get, get_target;

/*
----------INICIO----------*/

start with programa;

/*
----------PROGRAMA----------*/
/* Permite mezclar globales y funciones en cualquier orden antes de main */
programa ::=
      declaraciones_top:dt main:m
      {:
          Nodo n = new Nodo("programa");
          n.addHijo((Nodo)dt);
          n.addHijo((Nodo)m);
          raizAST = n;
          System.out.println("Programa reconocido.");
          raizAST.arbol();
          printTablas();
          printC3D();
          RESULT = n;
      :}
    | main:m
      {:
          Nodo n = new Nodo("programa");
          n.addHijo((Nodo)m);
          raizAST = n;
          System.out.println("Programa reconocido.");
          raizAST.arbol();
          printTablas();
          printC3D();
          RESULT = n;
      :}
    ;

/* Lista de declaraciones de nivel superior (globales y funciones mezcladas) */
declaraciones_top ::=
      declaraciones_top:dt decl_top:d
      {:
          Nodo n = (Nodo)dt;
          n.addHijo((Nodo)d);
          RESULT = n;
      :}
    | decl_top:d
      {:
          Nodo n = new Nodo("declaraciones");
          n.addHijo((Nodo)d);
          RESULT = n;
      :}
    | declaraciones_top error ENDL
      {:
          addError("[PANIC] Error en declaración global, sincronizado en ENDL.");
          Nodo n = new Nodo("declaraciones_error");
          RESULT = n;
      :}
    | declaraciones_top error BLOCK_CLOSE
      {:
          addError("[PANIC] Error en declaración de función, sincronizado en '!'.");
          Nodo n = new Nodo("declaraciones_error");
          RESULT = n;
      :}
    | error ENDL
      {:
          addError("[PANIC] Error en declaración global, sincronizado en ENDL.");
          Nodo n = new Nodo("declaraciones_error");
          RESULT = n;
      :}
    | error BLOCK_CLOSE
      {:
          addError("[PANIC] Error en declaración de función, sincronizado en '!'.");
          Nodo n = new Nodo("declaraciones_error");
          RESULT = n;
      :}
    ;

/* Una declaración de nivel superior puede ser global o función */
decl_top ::=
      decl_global:dg {: RESULT = dg; :}
    | funcion:f {: RESULT = f; :}
    ;
    
/*
----------GLOBALES----------*/
/* Las reglas funciones y globales ya no se usan por separado.
   Ahora se manejan a través de declaraciones_top y decl_top */

decl_global ::=
      WORLD tipo:t ID:id ENDL
      {:
          String idStr = id.toString();
          declareVar("world", ((Nodo)t).getTipo(), idStr, idleft, idright, false);
          
          Nodo n = new Nodo("decl_global");
          n.addHijo(new Nodo("world"));
          n.addHijo((Nodo)t);
          Nodo nid = new Nodo(idStr);
          nid.setTipo(((Nodo)t).getTipo());
          n.addHijo(nid);
          RESULT = n;
      :}
    | WORLD tipo:t ID:id ASSIGN expresion:e ENDL
      {:
          String idStr = id.toString();
          String tipoVar = ((Nodo)t).getTipo();
          declareVar("world", tipoVar, idStr, idleft, idright, false);

          // Verificar compatibilidad de tipos
          checkAssignment(tipoVar, ((Nodo)e).getTipo(), idStr, idleft, idright);

          // Generar C3D para la asignación global
          emit(idStr + " = " + ((Nodo)e).getDir());

          Nodo n = new Nodo("decl_global_asign");
          n.addHijo(new Nodo("world"));
          n.addHijo((Nodo)t);
          Nodo nid = new Nodo(idStr);
          nid.setTipo(tipoVar);
          n.addHijo(nid);
          n.addHijo(new Nodo("="));
          n.addHijo((Nodo)e);
          RESULT = n;
      :}
    | WORLD decl_arreglo:d ENDL
      {:
          Nodo n = new Nodo("decl_global_array");
          n.addHijo(new Nodo("world"));
          n.addHijo((Nodo)d);
          RESULT = n;
      :}
    | WORLD decl_arreglo:d ASSIGN arreglo_init:init ENDL
      {:
          Nodo n = new Nodo("decl_global_array_init");
          n.addHijo(new Nodo("world"));
          n.addHijo((Nodo)d);
          n.addHijo((Nodo)init);
          RESULT = n;
      :}
    ;

/*
----------DATOS----------*/

// tipo
tipo ::= 
            INT {:Nodo n=new Nodo("int");     n.setTipo("int");     RESULT=n; :}
        | FLOAT {:Nodo n=new Nodo("float");   n.setTipo("float");   RESULT=n; :}
        | BOOLEAN {:Nodo n=new Nodo("boolean"); n.setTipo("boolean"); RESULT=n; :}
        | CHAR {:Nodo n=new Nodo("char");    n.setTipo("char");    RESULT=n; :}
        | STRING {:Nodo n=new Nodo("string");  n.setTipo("string");  RESULT=n; :}
        ;

// literal
literal ::=
            INT_LIT:i {: Nodo n=new Nodo(i); n.setTipo("int"); n.setDir(i.toString()); RESULT=n; :}
        | FLOAT_LIT:f {: Nodo n=new Nodo(f); n.setTipo("float"); n.setDir(f.toString()); RESULT=n; :}
        | BOOLEAN_LIT:b {: Nodo n=new Nodo(b); n.setTipo("boolean"); n.setDir(b.toString()); RESULT=n; :}
        | CHAR_LIT:c {: Nodo n=new Nodo(c); n.setTipo("char"); n.setDir("'" + c.toString() + "'"); RESULT=n; :}
        | STRING_LIT:s {: Nodo n=new Nodo(s); n.setTipo("string"); n.setDir("\"" + s.toString() + "\""); RESULT=n; :}
        ;



// alcance
alcance ::= 
            WORLD
            {: Nodo n = new Nodo("world"); n.setTipo("world"); RESULT = n; :}
        | LOCAL
            {: Nodo n = new Nodo("local"); n.setTipo("local"); RESULT = n; :}
        ;

/*
----------FUNCIONES----------
*/

// params_opt
params_opt ::= 
            params:p {: RESULT=(Nodo)p; :}
        | /* empty */ {: RESULT=new Nodo("params_vacios"); :}
        ;

// params
params ::= 
            params:ps COMMA param:p
            {: 
                    Nodo n=(Nodo)ps;
                    n.addHijo(new Nodo(","));
                    n.addHijo((Nodo)p);
                    RESULT=n;
            :}
        | param:p
            {: 
                    Nodo n=new Nodo("params");
                    n.addHijo((Nodo)p);
                    RESULT=n;
            :}
        ;

param ::= 
      tipo:t ID:id
      {: 
          String idStr = id.toString();
          declareVar("local", ((Nodo)t).getTipo(), idStr, idleft, idright, true);

          Nodo n=new Nodo("param");
          n.addHijo((Nodo)t);
          Nodo nid=new Nodo(idStr); nid.setTipo(((Nodo)t).getTipo());
          n.addHijo(nid);
          RESULT=n;
      :}
    ;

/*
----------MAIN----------*/
main_start ::=
      COAL_TYPE NAVIDAD:nav
      {:
          declareMain(navleft, navright);
          pushNamedScope("navidad");
          // Generar etiqueta de inicio de main
          emit("# MAIN navidad");
          emit("navidad:");
      :}
    ;

main ::=
      main_start PARENTHESIS_OPEN PARENTHESIS_CLOSE bloque:b
      {:
          emit("# END MAIN");

          Nodo n=new Nodo("main");
          n.addHijo(new Nodo("coal"));
          n.addHijo(new Nodo("navidad"));
          n.addHijo((Nodo)b);

          popScope();

          RESULT=n;
      :}
    | main_start error BLOCK_CLOSE
      {:
          addError("[PANIC] Main navidad mal formado, sincronizado en cierre de bloque.");
          popScope();
          RESULT=new Nodo("main_error");
      :}
    ;

/*
----------FUNCION----------*/
funcion ::=
      GIFT tipo:t ID:id
      {:
          String idStr = id.toString();
          declareFunc(idStr, ((Nodo)t).getTipo(), idleft, idright);
          pushNamedScope(idStr);
          // Generar etiqueta de inicio de función
          emit("# FUNC " + idStr);
          emit(idStr + ":");
      :}
      PARENTHESIS_OPEN params_opt:po PARENTHESIS_CLOSE bloque:b
      {:
          String idStr = id.toString();
          emit("# END FUNC " + idStr);

          Nodo n=new Nodo("funcion");
          n.addHijo(new Nodo("gift"));
          Nodo nid=new Nodo(idStr); nid.setTipo(((Nodo)t).getTipo());
          n.addHijo((Nodo)t);
          n.addHijo(nid);
          n.addHijo((Nodo)po);
          n.addHijo((Nodo)b);

          popScope();

          RESULT=n;
      :}
    | GIFT error BLOCK_CLOSE
      {:
          addError("[PANIC] Función mal formada, sincronizado en cierre de bloque.");
          popScope();
          RESULT=new Nodo("funcion_error");
      :}
    ;

/*
----------DECLARACIONES----------*/

// creacion
creacion ::= 
      alcance:a tipo:t ID:id
      {: 
          String alc = ((Nodo)a).getTipo();
          String idStr = id.toString();
          declareVar(alc, ((Nodo)t).getTipo(), idStr, idleft, idright, false);

          Nodo n=new Nodo("creacion");
          n.addHijo((Nodo)a);
          Nodo nid=new Nodo(idStr); nid.setTipo(((Nodo)t).getTipo());
          n.addHijo((Nodo)t);
          n.addHijo(nid);
          RESULT=n;
      :}
    ;

// creacion_sentencia
creacion_sentencia ::= 
      creacion:c ENDL
      {: 
          Nodo n=new Nodo("creacion_sent");
          n.addHijo((Nodo)c);
          RESULT=n;
      :}
    ;

// asignacion
asignacion ::=
      alcance:a tipo:t ID:id ASSIGN expresion:e
      {:
          String alc=((Nodo)a).getTipo();
          String tipoVar = ((Nodo)t).getTipo();
          String idStr = id.toString();
          declareVar(alc, tipoVar, idStr, idleft, idright, false);

          // Verificar compatibilidad de tipos
          checkAssignment(tipoVar, ((Nodo)e).getTipo(), idStr, idleft, idright);

          // Generar C3D para la asignación
          emit(idStr + " = " + ((Nodo)e).getDir());

          Nodo n=new Nodo("asignacion_decl");
          n.addHijo((Nodo)a);
          Nodo nid=new Nodo(idStr); nid.setTipo(tipoVar);
          n.addHijo((Nodo)t);
          n.addHijo(nid);
          n.addHijo(new Nodo("="));
          n.addHijo((Nodo)e);
          n.setDir(idStr);
          RESULT=n;
      :}
    ;

// reasignacion
reasignacion ::=
      ID:id ASSIGN expresion:e
      {:
          String idStr = id.toString();
          checkID(idStr, idleft, idright);
          String varType = getIdType(idStr, idleft, idright);

          // Verificar compatibilidad de tipos
          checkAssignment(varType, ((Nodo)e).getTipo(), idStr, idleft, idright);

          // Generar C3D para la reasignación
          emit(idStr + " = " + ((Nodo)e).getDir());

          Nodo n=new Nodo("reasignacion");
          Nodo nid=new Nodo(idStr);
          nid.setTipo(varType);
          n.addHijo(nid);
          n.addHijo(new Nodo("="));
          n.addHijo((Nodo)e);
          n.setDir(idStr);
          RESULT=n;
      :}
    ;

// reasignacion_sentencia
reasignacion_sentencia ::= 
      reasignacion:r ENDL
      {: 
          Nodo n=new Nodo("reasignacion_sent");
          n.addHijo((Nodo)r);
          RESULT=n;
      :}
    ;

// asignacion_sentencia
asignacion_sentencia ::= 
      asignacion:a ENDL
      {: 
          Nodo n=new Nodo("asignacion_sent");
          n.addHijo((Nodo)a);
          RESULT=n;
      :}
    ;

// unario
unario ::= INCREMENT ID:id
                 {:
                     String idStr = id.toString();
                     checkID(idStr, idleft, idright);
                     String t = getIdType(idStr, idleft, idright);
                     checkUnary(t, "++", idleft, idright);
                     // Generar C3D para incremento
                     emit(idStr + " = " + idStr + " + 1");
                     Nodo n = new Nodo("++pre");
                     Nodo idn = new Nodo(idStr);
                     idn.setTipo(t);
                     idn.setDir(idStr);
                     n.addHijo(idn);
                     n.setTipo(t);
                     n.setDir(idStr);
                     RESULT = n;
                 :}
             | DECREMENT ID:id
                 {:
                     String idStr = id.toString();
                     checkID(idStr, idleft, idright);
                     String t = getIdType(idStr, idleft, idright);
                     checkUnary(t, "--", idleft, idright);
                     // Generar C3D para decremento
                     emit(idStr + " = " + idStr + " - 1");
                     Nodo n = new Nodo("--pre");
                     Nodo idn = new Nodo(idStr);
                     idn.setTipo(t);
                     idn.setDir(idStr);
                     n.addHijo(idn);
                     n.setTipo(t);
                     n.setDir(idStr);
                     RESULT = n;
                 :}
             | INCREMENT acceso_arreglo:a
                 {:
                     String t = ((Nodo)a).getTipo();
                     checkUnary(t, "++", aleft, aright);
                     String arrDir = ((Nodo)a).getDir();
                     // Generar C3D para incremento de elemento de arreglo
                     String temp = newTemp();
                     emit(temp + " = " + arrDir + " + 1");
                     emit(arrDir + " = " + temp);
                     Nodo n = new Nodo("++pre");
                     n.addHijo((Nodo)a);
                     n.setTipo(t);
                     n.setDir(arrDir);
                     RESULT = n;
                 :}
             | DECREMENT acceso_arreglo:a
                 {:
                     String t = ((Nodo)a).getTipo();
                     checkUnary(t, "--", aleft, aright);
                     String arrDir = ((Nodo)a).getDir();
                     // Generar C3D para decremento de elemento de arreglo
                     String temp = newTemp();
                     emit(temp + " = " + arrDir + " - 1");
                     emit(arrDir + " = " + temp);
                     Nodo n = new Nodo("--pre");
                     n.addHijo((Nodo)a);
                     n.setTipo(t);
                     n.setDir(arrDir);
                     RESULT = n;
                 :}
             ;

/*
----------SENTENCIAS----------
*/

// sentencias
sentencias ::= 
            sentencias:ss sentencia:s
            {: 
                    Nodo n=(Nodo)ss;
                    n.addHijo((Nodo)s);
                    RESULT=n;
            :}
        | sentencia:s
            {: 
                    Nodo n=new Nodo("sentencias");
                    n.addHijo((Nodo)s);
                    RESULT=n;
            :}
        | sentencias error sentencia
            {:
                    addError("[PANIC] Error en sentencias, recuperando en siguiente sentencia.");
                    Nodo n=new Nodo("sentencias_error");
                    RESULT=n;
            :}
        ;
    
/*
----------SENTENCIA----------
*/

sentencia ::=
      asignacion_sentencia:a {: RESULT = a; :}
    | reasignacion_sentencia:r {: RESULT = r; :}
    | creacion_sentencia:c {: RESULT = c; :}
    | creacion_arreglo:ca {: RESULT = ca; :}
    | estructura:e {: RESULT = e; :}
    | expresion:e ENDL
      {:
          Nodo n=new Nodo("expr_sent");
          n.addHijo((Nodo)e);
          RESULT=n;
      :}
    | asignacion_elemento:a {: RESULT = a; :} // asignacion
    | io:i {: RESULT = i; :}
    | BREAK ENDL
      {:
          // Generar C3D para break - saltar al final del loop más cercano
          if (!loopEndLabels.isEmpty()) {
              emit("goto " + loopEndLabels.peek());
          }
          Nodo n=new Nodo("break");
          RESULT=n;
      :}
    | RETURN expresion:e ENDL
      {:
          // Generar C3D para return
          emit("return " + ((Nodo)e).getDir());
          Nodo n=new Nodo("return");
          n.addHijo((Nodo)e);
          RESULT=n;
      :}
    | error ENDL
      {:
          addError("[PANIC] Sentencia inválida, sincronizado en ENDL.");
          RESULT=new Nodo("sentencia_error");
      :}
    ;

// BLOQUE
bloque ::=
      BLOCK_OPEN sentencias:s BLOCK_CLOSE
      {:
          Nodo n=new Nodo("bloque");
          n.addHijo(new Nodo("¡"));
          n.addHijo((Nodo)s);
          n.addHijo(new Nodo("!"));
          RESULT=n;
      :}
    | BLOCK_OPEN BLOCK_CLOSE
      {:
          Nodo n=new Nodo("bloque_vacio");
          n.addHijo(new Nodo("¡"));
          n.addHijo(new Nodo("!"));
          RESULT=n;
      :}
    | BLOCK_OPEN error BLOCK_CLOSE
      {:
          addError("[PANIC] Bloque inválido, sincronizado en '!'.");
          RESULT=new Nodo("bloque_error");
      :}
    ;

/*
----------CONTROL----------*/
estructura ::=
      for:f {: RESULT = f; :}
    | loop:l {: RESULT = l; :}
    | decide_of:d {: RESULT = d; :}
    ;

// for_init
for_init ::=
      asignacion:a {: RESULT = a; :}
    | creacion:c {: RESULT = c; :}
    | reasignacion:r {: RESULT = r; :}
    | tipo:t ID:id ASSIGN expresion:e
      {:
          String idStr = id.toString();
          String tipoVar = ((Nodo)t).getTipo();
          declareVar("local", tipoVar, idStr, idleft, idright, false);

          // Verificar compatibilidad de tipos
          checkAssignment(tipoVar, ((Nodo)e).getTipo(), idStr, idleft, idright);

          // Generar C3D para la asignación en for
          emit(idStr + " = " + ((Nodo)e).getDir());

          Nodo n=new Nodo("asignacion_for");
          n.addHijo((Nodo)t);
          Nodo nid=new Nodo(idStr); nid.setTipo(tipoVar);
          n.addHijo(nid);
          n.addHijo(new Nodo("="));
          n.addHijo((Nodo)e);
          n.setDir(idStr);
          RESULT=n;
      :}
    ;

// FOR - con scope propio para variables declaradas en el for
for_start ::=
      FOR
      {:
          pushAutoScope("for");
          // Generar etiquetas para el for y guardarlas
          String lblCond = newLabel();
          String lblEnd = newLabel();
          loopStartLabels.push(lblCond);
          loopEndLabels.push(lblEnd);
          emit("# FOR inicio");
      :}
    ;

for ::=
      for_start PARENTHESIS_OPEN for_init:fi ENDL expr_logica:cond ENDL expresion:e PARENTHESIS_CLOSE bloque:b ENDL
      {:
          // Recuperar etiquetas del for
          String lblCond = loopStartLabels.pop();
          String lblEnd = loopEndLabels.pop();

          // Nota: La inicialización ya se emitió en for_init
          // Emitir etiqueta de condición (el código de condición ya se emitió)
          emit(lblCond + ":");
          // Evaluar condición y saltar si es falsa
          emit("ifFalse " + ((Nodo)cond).getDir() + " goto " + lblEnd);
          // El bloque ya se ejecutó (las instrucciones ya están)
          // Incremento ya se evaluó en expresion:e
          emit("goto " + lblCond);
          emit(lblEnd + ":");
          emit("# FOR fin");

          Nodo n=new Nodo("for");
          n.addHijo((Nodo)fi);
          n.addHijo((Nodo)cond);
          n.addHijo((Nodo)e);
          n.addHijo((Nodo)b);
          popScope(); // Salir del scope del for
          RESULT=n;
      :}
    | for_start error ENDL
      {:
          addError("[PANIC] Estructura FOR inválida, sincronizado en ENDL.");
          loopStartLabels.pop();
          loopEndLabels.pop();
          popScope();
          RESULT=new Nodo("for_error");
      :}
    ;

// LOOP - con scope propio
loop_start ::=
      LOOP
      {:
          pushAutoScope("loop");
          // Emitir etiqueta de inicio del loop y guardarla en la pila
          String lblStart = newLabel();
          String lblEnd = newLabel();
          loopStartLabels.push(lblStart);
          loopEndLabels.push(lblEnd);
          emit("# LOOP inicio");
          emit(lblStart + ":");
      :}
    ;

loop ::=
      loop_start sentencias:s EXIT WHEN PARENTHESIS_OPEN expr_logica:cond PARENTHESIS_CLOSE ENDL END LOOP ENDL
      {:
          // Recuperar etiquetas del loop
          String lblStart = loopStartLabels.pop();
          String lblEnd = loopEndLabels.pop();
          // Si la condición es verdadera, salir del loop
          emit("if " + ((Nodo)cond).getDir() + " goto " + lblEnd);
          // Si no, volver al inicio
          emit("goto " + lblStart);
          emit(lblEnd + ":");
          emit("# LOOP fin");

          Nodo n=new Nodo("loop");
          n.addHijo((Nodo)s);
          n.addHijo((Nodo)cond);
          popScope(); // Salir del scope del loop
          RESULT=n;
      :}
    | loop_start error END LOOP ENDL
      {:
          addError("[PANIC] Estructura LOOP inválida, sincronizado en END LOOP.");
          loopStartLabels.pop();
          loopEndLabels.pop();
          popScope();
          RESULT=new Nodo("loop_error");
      :}
    ;

casos ::=
      casos:cs caso:c
      {:
          Nodo n=(Nodo)cs;
          n.addHijo((Nodo)c);
          RESULT=n;
      :}
    | caso:c
      {:
          Nodo n=new Nodo("casos");
          n.addHijo((Nodo)c);
          RESULT=n;
      :}
    ;

caso ::=
      expr_logica:cond ARROW
      {:
          pushAutoScope("caso");
          // Generar etiqueta para saltar al siguiente caso si la condición es falsa
          String lblNext = newLabel();
          emit("ifFalse " + ((Nodo)cond).getDir() + " goto " + lblNext);
          loopEndLabels.push(lblNext);
      :}
      bloque:b
      {:
          String lblNext = loopEndLabels.pop();
          emit(lblNext + ":");
          Nodo n=new Nodo("caso");
          n.addHijo((Nodo)cond);
          n.addHijo((Nodo)b);
          popScope(); // Salir del scope del caso
          RESULT=n;
      :}
    | error ARROW bloque:b
      {:
          addError("[PANIC] Condición de caso inválida, sincronizado en ARROW.");
          Nodo n=new Nodo("caso_error");
          n.addHijo((Nodo)b);
          RESULT=n;
      :}
    ;

// DECIDE OF - cada caso tiene su propio scope
decide_of ::=
      DECIDE OF casos:cs END DECIDE ENDL
      {:
          emit("# DECIDE fin");
          Nodo n=new Nodo("decide_of");
          n.addHijo((Nodo)cs);
          RESULT=n;
      :}
    | DECIDE OF casos:cs ELSE ARROW
      {:
          pushAutoScope("else");
          emit("# ELSE");
      :}
      bloque:b END DECIDE ENDL
      {:
          emit("# DECIDE fin");
          Nodo n=new Nodo("decide_of");
          n.addHijo((Nodo)cs);
          n.addHijo((Nodo)b);
          popScope(); // Salir del scope del else
          RESULT=n;
      :}
    | DECIDE OF error END DECIDE ENDL
      {:
          addError("[PANIC] Estructura DECIDE OF inválida, sincronizado en END DECIDE.");
          RESULT=new Nodo("decide_of_error");
      :}
    ;

/*----------ARREGLOS----------
*/

dim ::= ARRAY_OPEN INT_LIT:d1 ARRAY_CLOSE ARRAY_OPEN INT_LIT:d2 ARRAY_CLOSE
    {: Nodo n = new Nodo("dim"); Nodo n1 = new Nodo(d1); Nodo n2 = new Nodo(d2); n.addHijo(n1); n.addHijo(n2); RESULT = n; :}
    ;

decl_arreglo ::= tipo:t ID:id dim:dm
    {:
        Nodo n = new Nodo("decl_arreglo");
        n.addHijo((Nodo)t);
        Nodo nid = new Nodo(id);
        n.addHijo(nid);
        n.addHijo((Nodo)dm);
        RESULT = n;
    :}
    ;

creacion_arreglo ::= 
      alcance:a tipo:t ID:id dim:dm ENDL
        {:
            String alc = ((Nodo)a).getTipo();
            String idStr = id.toString();
            String tipo = ((Nodo)t).getTipo();
            
            Nodo dimNode = (Nodo)dm;
            int d1 = Integer.parseInt(((Nodo)dimNode.hijos.get(0)).lexema);
            int d2 = Integer.parseInt(((Nodo)dimNode.hijos.get(1)).lexema);
            
            declareArr(alc, tipo, idStr, d1, d2, idleft, idright);
            
            Nodo n = new Nodo("creacion_arreglo");
            n.addHijo((Nodo)a);
            Nodo declNode = new Nodo("decl_arreglo");
            declNode.addHijo((Nodo)t);
            Nodo nid = new Nodo(idStr);
            declNode.addHijo(nid);
            declNode.addHijo((Nodo)dm);
            n.addHijo(declNode);
            RESULT = n;
        :}
    | alcance:a tipo:t ID:id dim:dm ASSIGN arreglo_init:init ENDL
        {:
            String alc = ((Nodo)a).getTipo();
            String idStr = id.toString();
            String tipo = ((Nodo)t).getTipo();
            
            Nodo dimNode = (Nodo)dm;
            int d1 = Integer.parseInt(((Nodo)dimNode.hijos.get(0)).lexema);
            int d2 = Integer.parseInt(((Nodo)dimNode.hijos.get(1)).lexema);
            
            declareArr(alc, tipo, idStr, d1, d2, idleft, idright);
            
            Nodo n = new Nodo("creacion_arreglo_init");
            n.addHijo((Nodo)a);
            Nodo declNode = new Nodo("decl_arreglo");
            declNode.addHijo((Nodo)t);
            Nodo nid = new Nodo(idStr);
            declNode.addHijo(nid);
            declNode.addHijo((Nodo)dm);
            n.addHijo(declNode);
            n.addHijo((Nodo)init);
            RESULT = n;
        :}
    | alcance error ENDL
      {:
          addError("[PANIC] Declaración de arreglo inválida, sincronizado en ENDL.");
          RESULT=new Nodo("arreglo_error");
      :}
    ;

asignacion_elemento ::= acceso_arreglo:a ASSIGN expresion:e ENDL
    {:
        String arrType = ((Nodo)a).getTipo();
        String exprType = ((Nodo)e).getTipo();

        // Verificar compatibilidad de tipos
        if (!ERROR_TYPE.equals(arrType) && !ERROR_TYPE.equals(exprType)) {
            if (!arrType.equals(exprType)) {
                // Permitir promoción int -> float
                if (!("float".equals(arrType) && "int".equals(exprType))) {
                    addError("[SEM] Tipo incompatible en asignación a elemento de arreglo: esperaba " + arrType + ", encontrado " + exprType + " (" + aleft + "," + aright + ")");
                }
            }
        }

        // Generar C3D para asignación a elemento de arreglo
        // Obtener info del acceso: el nodo tiene id, e1, e2 como hijos
        Nodo accesoNodo = (Nodo)a;
        String arrId = accesoNodo.hijos.get(0).lexema;
        String idx1 = accesoNodo.hijos.get(1).getDir();
        String idx2 = accesoNodo.hijos.get(2).getDir();
        emit(arrId + "[" + idx1 + "][" + idx2 + "] = " + ((Nodo)e).getDir());

        Nodo n = new Nodo("asignacion_elemento");
        n.addHijo((Nodo)a);
        n.addHijo((Nodo)e);
        RESULT = n;
    :}
    ;

acceso_arreglo ::= ID:id ARRAY_OPEN expresion:e1 ARRAY_CLOSE ARRAY_OPEN expresion:e2 ARRAY_CLOSE
    {:
        String idStr = id.toString();
        checkArray(idStr, idleft, idright);

        // Verificar que los índices sean int
        checkArrayIndex(((Nodo)e1).getTipo(), e1left, e1right);
        checkArrayIndex(((Nodo)e2).getTipo(), e2left, e2right);

        // Obtener tipo del arreglo
        String arrType = getIdType(idStr, idleft, idright);

        // Generar C3D para acceso a arreglo
        String temp = newTemp();
        emit(temp + " = " + idStr + "[" + ((Nodo)e1).getDir() + "][" + ((Nodo)e2).getDir() + "]");

        Nodo n = new Nodo("acceso_arreglo");
        Nodo nid = new Nodo(idStr);
        n.addHijo(nid);
        n.addHijo((Nodo)e1);
        n.addHijo((Nodo)e2);
        n.setTipo(arrType);
        n.setDir(temp);
        RESULT = n;
    :}
    ; 

elementos ::= INT_LIT:i
    {: Nodo n = new Nodo("elementos"); Nodo lit = new Nodo(i); lit.setTipo("int"); n.addHijo(lit); RESULT = n; :}
    | CHAR_LIT:c
    {: Nodo n = new Nodo("elementos"); Nodo lit = new Nodo(c); lit.setTipo("char"); n.addHijo(lit); RESULT = n; :}
    | elementos:els COMMA INT_LIT:i
    {: Nodo n = (Nodo)els; n.addHijo(new Nodo(",")); Nodo lit = new Nodo(i); lit.setTipo("int"); n.addHijo(lit); RESULT = n; :}
    | elementos:els COMMA CHAR_LIT:c
    {: Nodo n = (Nodo)els; n.addHijo(new Nodo(",")); Nodo lit = new Nodo(c); lit.setTipo("char"); n.addHijo(lit); RESULT = n; :}
    ;

fila ::= BLOCK_OPEN elementos:els BLOCK_CLOSE
    {: Nodo n = new Nodo("fila"); n.addHijo((Nodo)els); RESULT = n; :}
    ;

filas ::= fila:f
    {: Nodo n = new Nodo("filas"); n.addHijo((Nodo)f); RESULT = n; :}
    | filas:fs COMMA fila:f
    {: Nodo n = (Nodo)fs; n.addHijo(new Nodo(",")); n.addHijo((Nodo)f); RESULT = n; :}
    ;

arreglo_init ::= BLOCK_OPEN filas:f BLOCK_CLOSE
    {: Nodo n = new Nodo("arreglo_init"); n.addHijo((Nodo)f); RESULT = n; :}
    ;



/*
----------LLAMADAS A FUNCIONES----------
*/

llamada ::= ID:id PARENTHESIS_OPEN args:a PARENTHESIS_CLOSE
        {:
            String idStr = id.toString();
            checkCall(idStr, idleft, idright);
            String retType = getFuncReturnType(idStr);

            // Generar C3D: emitir params y llamada
            Nodo argsNode = (Nodo)a;
            int paramCount = 0;
            for (Nodo hijo : argsNode.hijos) {
                if (!",".equals(hijo.lexema)) {
                    emit("param " + hijo.getDir());
                    paramCount++;
                }
            }
            String temp = newTemp();
            emit(temp + " = call " + idStr + ", " + paramCount);

            Nodo n = new Nodo("llamada");
            Nodo nid = new Nodo(idStr);
            n.addHijo(nid);
            n.addHijo((Nodo)a);
            n.setTipo(retType);
            n.setDir(temp);
            RESULT = n;
        :}
    | ID:id PARENTHESIS_OPEN PARENTHESIS_CLOSE
        {:
            String idStr = id.toString();
            checkCall(idStr, idleft, idright);
            String retType = getFuncReturnType(idStr);

            // Generar C3D: llamada sin argumentos
            String temp = newTemp();
            emit(temp + " = call " + idStr + ", 0");

            Nodo n = new Nodo("llamada");
            Nodo nid = new Nodo(idStr);
            n.addHijo(nid);
            n.setTipo(retType);
            n.setDir(temp);
            RESULT = n;
        :}
    ;

args ::= args:as COMMA expresion:e
        {: Nodo n = (Nodo)as; n.addHijo(new Nodo(",")); n.addHijo((Nodo)e); RESULT = n; :}
    | expresion:e
        {: Nodo n = new Nodo("args"); n.addHijo((Nodo)e); RESULT = n; :}
    ;

/*
----------EXPRESIONES----------
*/

expresion ::= expr_logica:e {: RESULT = e; :}
            ;

// ARITMÉTICAS

expr_aritm ::= expr_aritm:e1 PLUS term:e2
        {:
            String t = checkArithmetic(((Nodo)e1).getTipo(), ((Nodo)e2).getTipo(), "+", e1left, e1right);
            String temp = newTemp();
            emit(temp + " = " + ((Nodo)e1).getDir() + " + " + ((Nodo)e2).getDir());
            Nodo n = new Nodo("+");
            n.addHijo((Nodo)e1);
            n.addHijo((Nodo)e2);
            n.setTipo(t);
            n.setDir(temp);
            RESULT = n;
        :}
    | expr_aritm:e1 MINUS term:e2
        {:
            String t = checkArithmetic(((Nodo)e1).getTipo(), ((Nodo)e2).getTipo(), "-", e1left, e1right);
            String temp = newTemp();
            emit(temp + " = " + ((Nodo)e1).getDir() + " - " + ((Nodo)e2).getDir());
            Nodo n = new Nodo("-");
            n.addHijo((Nodo)e1);
            n.addHijo((Nodo)e2);
            n.setTipo(t);
            n.setDir(temp);
            RESULT = n;
        :}
    | term:t
        {: RESULT = t; :}
    ;

term ::= term:t1 TIMES power:t2
        {:
            String t = checkArithmetic(((Nodo)t1).getTipo(), ((Nodo)t2).getTipo(), "*", t1left, t1right);
            String temp = newTemp();
            emit(temp + " = " + ((Nodo)t1).getDir() + " * " + ((Nodo)t2).getDir());
            Nodo n = new Nodo("*");
            n.addHijo((Nodo)t1);
            n.addHijo((Nodo)t2);
            n.setTipo(t);
            n.setDir(temp);
            RESULT = n;
        :}
    | term:t1 DIV power:t2
        {:
            String t = checkArithmetic(((Nodo)t1).getTipo(), ((Nodo)t2).getTipo(), "/", t1left, t1right);
            String temp = newTemp();
            emit(temp + " = " + ((Nodo)t1).getDir() + " / " + ((Nodo)t2).getDir());
            Nodo n = new Nodo("/");
            n.addHijo((Nodo)t1);
            n.addHijo((Nodo)t2);
            n.setTipo(t);
            n.setDir(temp);
            RESULT = n;
        :}
    | term:t1 DIV_INT power:t2
        {:
            String t = checkArithmetic(((Nodo)t1).getTipo(), ((Nodo)t2).getTipo(), "//", t1left, t1right);
            // División entera siempre retorna int si ambos son numéricos
            if (!ERROR_TYPE.equals(t)) t = "int";
            String temp = newTemp();
            emit(temp + " = " + ((Nodo)t1).getDir() + " // " + ((Nodo)t2).getDir());
            Nodo n = new Nodo("//");
            n.addHijo((Nodo)t1);
            n.addHijo((Nodo)t2);
            n.setTipo(t);
            n.setDir(temp);
            RESULT = n;
        :}
    | term:t1 MODULE power:t2
        {:
            String t = checkArithmetic(((Nodo)t1).getTipo(), ((Nodo)t2).getTipo(), "%", t1left, t1right);
            String temp = newTemp();
            emit(temp + " = " + ((Nodo)t1).getDir() + " % " + ((Nodo)t2).getDir());
            Nodo n = new Nodo("%");
            n.addHijo((Nodo)t1);
            n.addHijo((Nodo)t2);
            n.setTipo(t);
            n.setDir(temp);
            RESULT = n;
        :}
    | power:p
        {: RESULT = p; :}
    ;

power ::= factor:f1 POWER power:f2
        {:
            String t = checkArithmetic(((Nodo)f1).getTipo(), ((Nodo)f2).getTipo(), "^", f1left, f1right);
            String temp = newTemp();
            emit(temp + " = " + ((Nodo)f1).getDir() + " ^ " + ((Nodo)f2).getDir());
            Nodo n = new Nodo("^");
            n.addHijo((Nodo)f1);
            n.addHijo((Nodo)f2);
            n.setTipo(t);
            n.setDir(temp);
            RESULT = n;
        :}
    | factor:f
        {: RESULT = f; :}
    ;

factor ::= literal:l
        {: RESULT = l; :}
    | ID:id
        {:
            String idStr = id.toString();
            checkID(idStr, idleft, idright);
            String t = getIdType(idStr, idleft, idright);
            Nodo n = new Nodo(idStr);
            n.setTipo(t);
            n.setDir(idStr);
            RESULT = n;
        :}
    | acceso_arreglo:a
        {: RESULT = a; :}
    | llamada:ll
        {: RESULT = ll; :}
    | MINUS INT_LIT:i
        {:
            String temp = newTemp();
            emit(temp + " = -" + i.toString());
            Nodo n = new Nodo("neg");
            Nodo lit = new Nodo(i);
            lit.setTipo("int");
            lit.setDir(i.toString());
            n.addHijo(lit);
            n.setTipo("int");
            n.setDir(temp);
            RESULT = n;
        :}
    | MINUS FLOAT_LIT:f
        {:
            String temp = newTemp();
            emit(temp + " = -" + f.toString());
            Nodo n = new Nodo("neg");
            Nodo lit = new Nodo(f);
            lit.setTipo("float");
            lit.setDir(f.toString());
            n.addHijo(lit);
            n.setTipo("float");
            n.setDir(temp);
            RESULT = n;
        :}
    | unario:u
        {: RESULT = u; :}
    | PARENTHESIS_OPEN expresion:e PARENTHESIS_CLOSE
        {: RESULT = e; :}
    ;

// RELACIONALES

expr_relacional ::= expresion_rel:e1 operador_rel:op expresion_rel:e2
    {:
        String t = checkRelational(((Nodo)e1).getTipo(), ((Nodo)e2).getTipo(), (String)op, e1left, e1right);
        String temp = newTemp();
        emit(temp + " = " + ((Nodo)e1).getDir() + " " + (String)op + " " + ((Nodo)e2).getDir());
        Nodo n = new Nodo(op);
        n.addHijo((Nodo)e1);
        n.addHijo((Nodo)e2);
        n.setTipo(t);
        n.setDir(temp);
        RESULT = n;
    :}
    ;

expresion_rel ::= expr_aritm:e {: RESULT = e; :}
                ;

operador_rel ::= LESS_THAN      {: RESULT = "<"; :}
              | LESS_OR_EQ_THAN {: RESULT = "<="; :}
              | MORE_THAN      {: RESULT = ">"; :}
              | MORE_OR_EQ_THAN {: RESULT = ">="; :}
              | EQUALS         {: RESULT = "=="; :}
              | DIFFERENT      {: RESULT = "!="; :}
              ;

// LOGICAS:

expr_logica ::= expr_logica:e1 OR expr_and:e2
        {:
            checkBoolean(((Nodo)e1).getTipo(), "or", e1left, e1right);
            checkBoolean(((Nodo)e2).getTipo(), "or", e2left, e2right);
            String temp = newTemp();
            emit(temp + " = " + ((Nodo)e1).getDir() + " or " + ((Nodo)e2).getDir());
            Nodo n = new Nodo("or");
            n.addHijo((Nodo)e1);
            n.addHijo((Nodo)e2);
            n.setTipo("boolean");
            n.setDir(temp);
            RESULT = n;
        :}
    | expr_and:e
        {: RESULT = e; :}
    ;

expr_and ::= expr_and:e1 AND expr_not:e2
        {:
            checkBoolean(((Nodo)e1).getTipo(), "and", e1left, e1right);
            checkBoolean(((Nodo)e2).getTipo(), "and", e2left, e2right);
            String temp = newTemp();
            emit(temp + " = " + ((Nodo)e1).getDir() + " and " + ((Nodo)e2).getDir());
            Nodo n = new Nodo("and");
            n.addHijo((Nodo)e1);
            n.addHijo((Nodo)e2);
            n.setTipo("boolean");
            n.setDir(temp);
            RESULT = n;
        :}
    | expr_not:e
        {: RESULT = e; :}
    ;

expr_not ::= NOT expr_not:e
        {:
            checkBoolean(((Nodo)e).getTipo(), "not", eleft, eright);
            String temp = newTemp();
            emit(temp + " = not " + ((Nodo)e).getDir());
            Nodo n = new Nodo("not");
            n.addHijo((Nodo)e);
            n.setTipo("boolean");
            n.setDir(temp);
            RESULT = n;
        :}
    | expr_bool:e
        {: RESULT = e; :}
    ;

expr_bool ::= expr_relacional:e
        {: RESULT = e; :}
    | expr_aritm:e
        {: RESULT = e; :}
    ;

/* -----I/O----- */

io ::= show:s {: RESULT = s; :}
    | get:g {: RESULT = g; :}
    ;

show ::= SHOW PARENTHESIS_OPEN show_arg:a PARENTHESIS_CLOSE ENDL
    {:
        // Generar C3D para print con tipo
        Nodo arg = (Nodo)a;
        String tipo = arg.getTipo();
        String cmd = "print";
        
        if (tipo != null) {
            if (tipo.equals("int")) cmd = "print_int";
            else if (tipo.equals("float")) cmd = "print_float";
            else if (tipo.equals("char")) cmd = "print_char";
            else if (tipo.equals("string")) cmd = "print_string";
        }
        
        emit(cmd + " " + arg.getDir());
        Nodo n = new Nodo("show");
        n.addHijo(arg);
        RESULT = n;
    :}
    ;

show_arg ::= expresion:e {: RESULT = e; :}
         ;

get ::= GET PARENTHESIS_OPEN get_target:t PARENTHESIS_CLOSE ENDL
    {:
        // Generar C3D para read con tipo
        String idv = ((Nodo)t).getDir();
        SymInfo info = lookup(idv);
        String tipo = (info != null) ? info.type : "int";
        String cmd = "read";

        if (tipo.equals("int")) cmd = "read_int";
        else if (tipo.equals("float")) cmd = "read_float";
        else if (tipo.equals("char")) cmd = "read_char";
        else if (tipo.equals("string")) cmd = "read_string";

        emit(cmd + " " + idv);
        Nodo n = new Nodo("get");
        n.addHijo((Nodo)t);
        RESULT = n;
    :}
    ;

get_target ::= ID:id
           {:
               String idStr = id.toString();
               checkID(idStr, idleft, idright);
               Nodo n = new Nodo(idStr);
               n.setDir(idStr);
               RESULT = n;
           :}
           | acceso_arreglo:a {: RESULT = a; :}
           ;

