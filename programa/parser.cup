package ParserLexer;

import java_cup.runtime.*;

/* Conectar CUP con lexer JFlex */
scan with {: return ((Lexer)scanner).next_token(); :};

parser code {:
    public void syntax_error(Symbol s) {
        System.err.println("Error de sintaxis en línea " + s.left);
    }
:}

/* ========================= TABLA DE SIMBOLOS =============================== */

parser code {:

    // Apunta a la raiz del AST 
    public Nodo raizAST = null;

    //SYMINFO: Qué guarda cada símbolo en la tabla de simbolos

    static class SymInfo {
        String kind;      // VAR, ARR, PARAM, FUNC, MAIN
        String type;      // int/float/boolean/char/string/coal
        Integer dim1;     // para arreglos
        Integer dim2;     // para arreglos
        int line, col;

        SymInfo(String kind, String type, int line, int col) {
            this.kind = kind;
            this.type = type;
            this.line = line;
            this.col = col;
        }

        SymInfo(String kind, String type, int dim1, int dim2, int line, int col) {
            this.kind = kind;
            this.type = type;
            this.dim1 = dim1;
            this.dim2 = dim2;
            this.line = line;
            this.col = col;
        }

        @Override
        public String toString() {
            if (dim1 != null && dim2 != null) {
                return kind + " : " + type + "[" + dim1 + "][" + dim2 + "]" + " (" + line + "," + col + ")";
            }
            return kind + " : " + type + " (" + line + "," + col + ")";
        }
    }

    // Tablas por scope específico | scopeName -> (id -> SymInfo) 
    HashMap<String, HashMap<String, SymInfo>> tablas = new HashMap<>();

    // Jerarquía de Scopes | scopeName -> parentScopeName  (jerarquía)
    HashMap<String, String> parentScope = new HashMap<>();

    // Contador de nombres únicos para los scopes
    HashMap<String, Integer> counters = new HashMap<>();

    // Pila real de scopes
    Deque<String> scopeStack = new ArrayDeque<>();

    ArrayList<String> errores = new ArrayList<>();

    // Tabla Global: Inicializa y pone el scope en world
    void initTablas() {
        tablas.put("world", new HashMap<>());
        parentScope.put("world", null);
        scopeStack.clear();
        scopeStack.push("world");
    }

    String currentScope() {
        return scopeStack.peek();
    }

    // Genera máscara única basada en el scope actual + kind
    String genScopeName(String kind) {
        String parent = currentScope();
        String key = parent + "#" + kind;
        int n = counters.getOrDefault(key, 0) + 1;
        counters.put(key, n);
        return parent + "_" + kind + n;   // ej: navidad_bloque1, NombreFunc_for2, NombreFunc_for2_bloque1...
    }
    
    /* Hace 3 cosas:
    1. Si no existe una tabla para un scope especifico, la crea
    2. Si no tiene papá registrado, pone de padre al scope actual
    3. Mete el scope a la pila y lo vuelve el current
     */
    void pushNamedScope(String name) {
        if (!tablas.containsKey(name)) tablas.put(name, new HashMap<>());
        if (!parentScope.containsKey(name)) parentScope.put(name, currentScope());
        scopeStack.push(name);
    }

    // Entra a un scope nuevo (lo mete a la pila) y le genera una máscara
    void pushAutoScope(String kind) {
        pushNamedScope(genScopeName(kind));
    }

    // Sale del scope actual
    void popScope() {
        if (scopeStack.size() > 1) scopeStack.pop(); // nunca sacar world
    }
    
    void addError(String msg) {
        errores.add(msg);
        System.err.println(msg);
    }

    /* Visibilidad hacia arriba:
    Busca una variable/func/arreglo siguiendo la jerarquía de scopes
    Si el símbolo no está en el current, sube al papá, y así hasta encontrarlo o llegar a world y poner null
    
     */
    SymInfo lookup(String id) {
        String s = currentScope();
        while (s != null) {
            HashMap<String, SymInfo> t = tablas.get(s);
            if (t != null && t.containsKey(id)) return t.get(id);
            s = parentScope.get(s); // Sube al tata
        }
        return null;
    }
    // Revisa si el ID ya existe en el scope actual para detectar duplicados
    boolean existsInCurrent(String id) {
        return tablas.get(currentScope()).containsKey(id);
    }

    // Verifica que un identificador exista 
    void checkID(String id, int line, int col) {
        if (lookup(id) == null) {
            addError("[SEM] Uso de ID no declarado: " + id + " (" + line + "," + col + ")");
        }
    }

    // Declara un símbolo en un scope específico
    void declareInScope(String scope, String id, SymInfo info) {
        HashMap<String, SymInfo> t = tablas.get(scope);
        if (t.containsKey(id)) {
            addError("[SEM] Duplicado en scope '" + scope + "': " + id + " (" + info.line + "," + info.col + ")");
            return;
        }
        t.put(id, info);
    }

    // Declara variables o parámetros y los mete a la tabla que corresponda (local o world)
    void declareVar(String alcance, String tipo, String id, int line, int col, boolean isParam) {
        if ("world".equals(alcance)) {
            declareInScope("world", id, new SymInfo(isParam ? "PARAM" : "VAR", tipo, line, col));
            return;
        }
        // local
        if ("world".equals(currentScope())) {
            addError("[SEM] 'local' fuera de función/navidad/bloque: " + id + " (" + line + "," + col + ")");
            return;
        }
        declareInScope(currentScope(), id, new SymInfo(isParam ? "PARAM" : "VAR", tipo, line, col));
    }

    // Igual que declareVar pero para arrays
    void declareArr(String alcance, String tipo, String id, int d1, int d2, int line, int col) {
        if ("world".equals(alcance)) {
            declareInScope("world", id, new SymInfo("ARR", tipo, d1, d2, line, col));
            return;
        }
        if ("world".equals(currentScope())) {
            addError("[SEM] 'local' fuera de función/navidad/bloque (arreglo): " + id + " (" + line + "," + col + ")");
            return;
        }
        declareInScope(currentScope(), id, new SymInfo("ARR", tipo, d1, d2, line, col));
    }

|   // Declara una función en world
    void declareFunc(String id, String tipoRet, int line, int col) {
        HashMap<String, SymInfo> w = tablas.get("world");
        if (w.containsKey(id)) {
            addError("[SEM] Duplicado global en world: " + id + " (" + line + "," + col + ")");
            return;
        }
        w.put(id, new SymInfo("FUNC", tipoRet, line, col));
    }

    // Declara el main navidad en world
    void declareMain(int line, int col) {
        HashMap<String, SymInfo> w = tablas.get("world");
        if (w.containsKey("navidad")) {
            addError("[SEM] Duplicado main navidad (" + line + "," + col + ")");
            return;
        }
        w.put("navidad", new SymInfo("MAIN", "coal", line, col));
    }

    // Verifica llamadas, que ID exista en world y sea FUNC o MAIN
    void checkCall(String id, int line, int col) {
        HashMap<String, SymInfo> w = tablas.get("world");
        if (!w.containsKey(id)) {
            addError("[SEM] Llamada a función inexistente: " + id + " (" + line + "," + col + ")");
            return;
        }
        String k = w.get(id).kind;
        if (!"FUNC".equals(k) && !"MAIN".equals(k)) {
            addError("[SEM] Llamada a no-función: " + id + " (" + line + "," + col + ")");
        }
    }

    // Verifica que el id exista y que sea ARR
    void checkArray(String id, int line, int col) {
        SymInfo si = lookup(id);
        if (si == null) {
            addError("[SEM] Acceso a arreglo no declarado: " + id + " (" + line + "," + col + ")");
            return;
        }
        if (!"ARR".equals(si.kind)) {
            addError("[SEM] Acceso arreglo sobre símbolo no-arreglo: " + id + " (" + line + "," + col + ")");
        }
    }

    void printTablas() {
        System.out.println("\n================ TABLAS DE SIMBOLOS (JERARQUIA) ==============");
        // Imprimir en orden jerárquico: world y luego lo otro
        System.out.println("Scope: world");
        for (Map.Entry<String, SymInfo> e : tablas.get("world").entrySet()) {
            System.out.println("  " + e.getKey() + " -> " + e.getValue());
        }
        System.out.println();

        for (String scope : tablas.keySet()) {
            if ("world".equals(scope)) continue;
            System.out.println("Scope: " + scope + " (parent=" + parentScope.get(scope) + ")");
            for (Map.Entry<String, SymInfo> e : tablas.get(scope).entrySet()) {
                System.out.println("  " + e.getKey() + " -> " + e.getValue());
            }
            System.out.println();
        }

        if (!errores.isEmpty()) {
            System.out.println("================ ERRORES/AVISOS ================");
            for (String e : errores) System.out.println(e);
        }
        System.out.println("=================================================\n");
    }

    /*======== ERRORES SINTACTICOS =========*/
    public void syntax_error(Symbol s) {
        addError("[SINT] Error de sintaxis en línea " + s.left + " cerca de: " + terminalToString(s));
    }

    public void report_error(String message, Object info) {
        addError("[SINT] " + message);
    }

    private String terminalToString(Symbol s) {
        try {
            return sym.terminalNames[s.sym] + (s.value != null ? ("('" + s.value + "')") : "");
        } catch(Exception e) {
            return "<?>"; 
        }
    }

:}

init with {: initTablas(); :};

precedence left OR;
precedence left AND;
precedence right NOT;

precedence left PLUS, MINUS;
precedence left TIMES, DIV, DIV_INT, MODULE;
precedence right POWER;

precedence right UMINUS;

precedence right INCREMENT, DECREMENT;


/* ------------TERMINALES------------ */

terminal BLOCK_OPEN, BLOCK_CLOSE, NAVIDAD, GIFT, WORLD, INT, FLOAT, BOOLEAN, CHAR, STRING, LOCAL, COAL_TYPE;
terminal DECIDE, OF, END, ELSE, LOOP, EXIT, WHEN, FOR, BREAK, RETURN;
terminal ARROW, ENDL, ASSIGN, PARENTHESIS_OPEN, PARENTHESIS_CLOSE, ARRAY_OPEN, ARRAY_CLOSE, COMMA;
terminal PLUS, MINUS, TIMES, DIV_INT, DIV, MODULE, POWER;
terminal LESS_OR_EQ_THAN, LESS_THAN, MORE_OR_EQ_THAN, MORE_THAN, EQUALS, DIFFERENT;
terminal AND, OR, NOT;
terminal DECREMENT, INCREMENT;
terminal SHOW, GET;
terminal INT_LIT, FLOAT_LIT, BOOLEAN_LIT, CHAR_LIT, STRING_LIT;
terminal ID;

/* ------------NO TERMINALES------------ */

non terminal programa, funciones, funcion, main;
non terminal tipo, literal, alcance;
non terminal params, param;
non terminal creacion, creacion_sentencia, asignacion, asignacion_sentencia;
non terminal unario;
non terminal sentencias, sentencia, bloque;
non terminal estructura, for_init, for, loop, decide_of;
non terminal casos, caso;
non terminal arreglo, dim, decl_arreglo, creacion_arreglo;
non terminal asignacion_elemento, acceso_arreglo;
non terminal elementos, fila, filas, arreglo_init;
non terminal tipo_arreglo, lit_array;
non terminal llamada, args;
non terminal expresion;
non terminal expr_aritm, term, power, factor;
non terminal expr_relacional, expresion_rel, operador_rel;
non terminal expr_logica, expr_and, expr_not, expr_bool;
non terminal io, show, show_arg, get, get_target;

/* ------------INICIO------------ */

start with programa;

/* ------------PRODUCCIONES------------ */

programa ::= funciones main
           | main
           ;

funciones ::= funciones funcion
            | funcion
            ;

/* -----Datos----- */

tipo ::=
      INT {:Nodo n=new Nodo("int");     n.setTipo("int");     RESULT=n; :}
    | FLOAT {:Nodo n=new Nodo("float");   n.setTipo("float");   RESULT=n; :}
    | BOOLEAN {:Nodo n=new Nodo("boolean"); n.setTipo("boolean"); RESULT=n; :}
    | CHAR {:Nodo n=new Nodo("char");    n.setTipo("char");    RESULT=n; :}
    | STRING {:Nodo n=new Nodo("string");  n.setTipo("string");  RESULT=n; :}
    ;

literal ::=
      INT_LIT:i {: Nodo n=new Nodo(i); n.setTipo("int"); RESULT=n; :}
    | FLOAT_LIT:f {: Nodo n=new Nodo(f); n.setTipo("float"); RESULT=n; :}
    | BOOLEAN_LIT:b {: Nodo n=new Nodo(b); n.setTipo("boolean"); RESULT=n; :}
    | CHAR_LIT:c {: Nodo n=new Nodo(c); n.setTipo("char"); RESULT=n; :}
    | STRING_LIT:s {: Nodo n=new Nodo(s); n.setTipo("string"); RESULT=n; :}
    ;

alcance ::= WORLD | LOCAL ;

/* -----funciones----- */

params ::= params COMMA param
         | param
         ;

param ::= tipo ID ;

main ::= COAL_TYPE NAVIDAD PARENTHESIS_OPEN PARENTHESIS_CLOSE bloque ;

funcion ::= GIFT tipo ID PARENTHESIS_OPEN params PARENTHESIS_CLOSE bloque |
            GIFT tipo ID PARENTHESIS_OPEN PARENTHESIS_CLOSE bloque;

/* -----Declaraciones----- */

creacion ::= alcance tipo ID
           | asignacion
           ;

creacion_sentencia ::= creacion ENDL ;

asignacion ::= alcance tipo ID ASSIGN expresion ;

asignacion_sentencia ::= asignacion ENDL ;

unario ::= INCREMENT ID
         | DECREMENT ID
         | INCREMENT acceso_arreglo
         | DECREMENT acceso_arreglo
         ;

/* -----sentencias----- */

sentencias ::= sentencias sentencia
             | sentencia
             ;

sentencia ::= asignacion_sentencia
            | creacion_sentencia
            | estructura
            | expresion ENDL
            | asignacion_elemento
            | io
            | BREAK ENDL
            | RETURN expresion ENDL
            ;

bloque ::= BLOCK_OPEN sentencias BLOCK_CLOSE
         | BLOCK_OPEN BLOCK_CLOSE
         ;

/* -----control----- */

estructura ::= for
             | loop
             | decide_of
             | arreglo
             ;

for_init ::= asignacion
           | creacion
           ;

for ::= FOR PARENTHESIS_OPEN for_init ENDL expr_logica ENDL unario PARENTHESIS_CLOSE bloque ;

loop ::= LOOP bloque EXIT WHEN expr_logica ENDL END LOOP ENDL ;

casos ::= casos caso
        | caso
        ;

caso ::= expr_logica ARROW bloque ;

decide_of ::= DECIDE OF casos END DECIDE ENDL
            | DECIDE OF casos ELSE bloque END DECIDE ENDL
            ;

/* -----arreglos----- */

arreglo ::= creacion_arreglo ;

dim ::= ARRAY_OPEN INT_LIT ARRAY_CLOSE ARRAY_OPEN INT_LIT ARRAY_CLOSE ;

decl_arreglo ::= tipo ID dim ;

creacion_arreglo ::= alcance decl_arreglo ENDL
                   | alcance decl_arreglo ASSIGN arreglo_init ENDL
                   ;

asignacion_elemento ::= acceso_arreglo ASSIGN lit_array ENDL ;

acceso_arreglo ::= ID ARRAY_OPEN expresion ARRAY_CLOSE ARRAY_OPEN expresion ARRAY_CLOSE ;

elementos ::= lit_array
            | elementos COMMA lit_array
            ;

fila ::= BLOCK_OPEN elementos BLOCK_CLOSE ;

filas ::= fila
        | filas COMMA fila
        ;

arreglo_init ::= BLOCK_OPEN filas BLOCK_CLOSE ;


lit_array ::= INT_LIT | CHAR_LIT ;

/* -----llamadas----- */

llamada ::= ID PARENTHESIS_OPEN args PARENTHESIS_CLOSE
          | ID PARENTHESIS_OPEN PARENTHESIS_CLOSE
          ;

args ::= args COMMA expresion
       | expresion
       ;

/* -----Expresiones----- */

expresion ::= literal
            | ID
            | expr_aritm
            | expr_relacional
            | expr_logica
            | acceso_arreglo
            | llamada
            ;

/* -----aritmeicas----- */

expr_aritm ::= expr_aritm PLUS term
             | expr_aritm MINUS term
             | term
             ;

term ::= term TIMES power
       | term DIV power
       | term DIV_INT power
       | term MODULE power
       | power
       ;

power ::= factor POWER power
        | factor
        ;

factor ::= literal
         | ID
         | acceso_arreglo
         | llamada
         | MINUS factor
         | unario
         | PARENTHESIS_OPEN expresion PARENTHESIS_CLOSE
         ;

/* -----relacionales----- */

expr_relacional ::= expresion_rel operador_rel expresion_rel ;

expresion_rel ::= expr_aritm
                | BOOLEAN_LIT
                | ID
                ;

operador_rel ::= LESS_THAN
               | LESS_OR_EQ_THAN
               | MORE_THAN
               | MORE_OR_EQ_THAN
               | EQUALS
               | DIFFERENT
               ;

/* -----logicas----- */

expr_logica ::= expr_logica OR expr_and
              | expr_and
              ;

expr_and ::= expr_and AND expr_not
           | expr_not
           ;

expr_not ::= NOT expr_not
           | expr_bool
           ;

expr_bool ::= BOOLEAN_LIT
            | ID
            | expr_relacional
            | PARENTHESIS_OPEN expr_logica PARENTHESIS_CLOSE
            ;

/* -----I/O----- */

io ::= show
     | get
     ;

show ::= SHOW PARENTHESIS_OPEN show_arg PARENTHESIS_CLOSE ENDL ;

show_arg ::= literal
           | ID
           | acceso_arreglo
           ;

get ::= GET PARENTHESIS_OPEN get_target PARENTHESIS_CLOSE ENDL ;

get_target ::= ID
             | acceso_arreglo
             ;

